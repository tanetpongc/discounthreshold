---
title: "Price Discount Analysis for Cereals"
author: "Tanetpong"
date: "26/10/2021"
output: pdf_document
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../../gen/analysis") })
---

```{r setup and require library, include=FALSE, WARNING = FALSE}
library(dplyr) #for mutate factor level of brand
library(plyr) #for revalue function for brand
library(data.table) #for set DT checking brand
library(car) #testing differences in coefficients using frequentist way
library(lmtest) #testing for relevance of the variable using likelihood ratio
```

# Data Management

```{r read data, echo=FALSE}
df_scanner <- read.csv("../../data/df_scanner.csv")
df <-subset(df_scanner,category == "Cereals")
df <- df %>% mutate(brand=droplevels(brand)) #Because the subset function doesnt drop the factor per se
df <- df %>% mutate(vecka=droplevels(as.factor(vecka))) #In case some categories doesnt have full week like another
#for simplicity, we will drop online sales for now (due to small data)
df_online <- subset(df, saljkanal == 1)
message(paste("The total number of weekly online sold for this category:", dim(df_online)[1]))
df <- subset(df, saljkanal == 0)
remove(list=c("df_scanner", "df_online")) #remove unnecessary file to make environment clean
df_holiday <- read.csv("../../data/weeklyholiday.csv")
df_holiday$vecka <- as.factor(df_holiday$vecka)
```

```{r Rename the brand of cereal for consistency, be careful of non-roman character}
knitr::kable(table(df$brand),col.names = c('Brand','Frequency'))
df$brand<- revalue(df$brand, c(
              "Honey Monster"="Honey Monster",
              "ICA Basic"="ICA", 
              #"ICA Gott Liv"="ICA","ICA Basic"="ICA", "ICA I love eco"="ICA", because they have a different perception
              "KUNG MARKATTA"="Kung markatta",
              "Paulun"="Pauluns",
              "QUAKER"="Quaker",
              "RenÃ©e Voltaire"="ReneeVoltaire", "RENÃ‰E VOLTAIRE"="ReneeVoltaire"
              ))
knitr::kable(table(df$brand),col.names = c('Brand After Revalue','Frequency'))
```

```{r select the brand with every weekly sales regardless of sku, echo=FALSE}
#create a table of distinct week
distinctweek<-unique(df$vecka)
message(paste("The total number of week sold for this category:", length(distinctweek)))
#calculate the brand sales by week
distinctbrand<-unique(df$brand)
message(paste("The total number of brand for this category:", length(distinctbrand)))
brandsalecount<-setDT(df)[, .N, .(vecka,brand)]
brandweeksalestime<-setDT(brandsalecount)[, .N, .(brand)]#we count if the brand got shown in the scanner data each week
#select the brand that have complete week
brandcompleteweek<-subset(brandweeksalestime, N >= length(distinctweek))
brandcompleteweek <- brandcompleteweek %>% mutate(brand=droplevels(brand))
distinctbrandcomplete<-unique(brandcompleteweek$brand)
message(paste("The total number of brand that has complete observation for this category:", dim(brandcompleteweek)[1]))

df_complete <- df[df$brand %in% brandcompleteweek$brand, ]
df_complete <- df_complete %>% mutate(brand=droplevels(brand))
message(paste("The number of observation before dropping non-complete brand:", dim(df)[1]))
message(paste("The number of observation after dropping non-complete brand:", dim(df_complete)[1]))

#remove used data
remove(list=c("brandsalecount", "brandweeksalestime","brandcompleteweek","df")) 
```

We want to compare between the *change in final price* vis a vis the *change in discount* and interesting to see the price before (now we will compare three aspects). Hence, we will create an aggregate price-related variable and line-length (aka assortment).
```{r calculate the brand price related variables and linelength or our main IV, echo=FALSE}
#Number of unique SKUs sold by brand b in period t
#Price of brand b in period t, computed as a sales-weighted average across its SKUs sold in period t
df_complete$pricebeforeperunit <- df_complete$spendingbeforedisc/df_complete$sales_volume
df_complete$finalpriceperunit <- df_complete$finalspending/df_complete$sales_volume
df_complete$discountperunit <- df_complete$totaldiscount/df_complete$sales_volume
#calculated weight
weeklysalesbybrand<-setDT(df_complete)[, .(totalsales=sum(finalspending),LL=uniqueN(produkt_id)), .(vecka,brand)]
df_weightcalc <- merge(df_complete,weeklysalesbybrand, by=c("vecka","brand"))
df_weightcalc$wp <- df_weightcalc$finalspending/df_weightcalc$totalsales
    # check<-setDT(df_weightcalc)[, .(totalwp=sum(wp)), .(vecka,brand)] #check if weight sum to 1
df_weightcalc$avgpricebefore <- df_weightcalc$pricebeforeperunit*df_weightcalc$wp
df_weightcalc$avgfinalprice <- df_weightcalc$finalpriceperunit*df_weightcalc$wp
df_weightcalc$avgdiscount <- df_weightcalc$discountperunit*df_weightcalc$wp
df_bybrand <- setDT(df_weightcalc)[, .(totalvolume=sum(sales_volume),totalvalue=sum(finalspending),LL=mean(LL),avgpricebefore=sum(avgpricebefore),avgfinalprice=sum(avgfinalprice),avgdiscount=sum(avgdiscount)), .(vecka,brand)]

#remove prior df
remove(list=c("df_complete","weeklysalesbybrand", "df_weightcalc"))
```

We also have to create competitor price and line-length.
```{r calculate the competitor price, echo=FALSE}
nbrand<-length(distinctbrandcomplete)
nweek<-length(distinctweek)
df_rep <- data.frame(matrix(NA, ncol = 12 , nrow = ((nbrand)*(nweek)))) #create an empty table for iteration information of each brand

#We calculate competitors info for each brand and then replace in the df_rep (rbind each brand)
for (i in 1:length(distinctbrandcomplete)){
df_competitor=df_bybrand[df_bybrand$brand != distinctbrandcomplete[i],]
weeklysalesbycompetingbrand<-setDT(df_competitor)[, .(totalmarketvalue=sum(totalvalue)), .(vecka)]
df_competitorweightcalc <- merge(df_competitor,weeklysalesbycompetingbrand, by=c("vecka"))
df_competitorweightcalc$wp <- df_competitorweightcalc$totalvalue/df_competitorweightcalc$totalmarketvalue
  # check<-setDT(df_competitorweightcalc)[, .(totalwp=sum(wp)), .(vecka)] #check if weight sum to 1
df_competitorweightcalc$avgcompLL <- df_competitorweightcalc$LL*df_competitorweightcalc$wp
df_competitorweightcalc$avgcomppricebefore <- df_competitorweightcalc$avgpricebefore*df_competitorweightcalc$wp
df_competitorweightcalc$avgcompfinalprice <- df_competitorweightcalc$avgfinalprice*df_competitorweightcalc$wp
df_competitorweightcalc$avgcompdiscount <- df_competitorweightcalc$avgdiscount*df_competitorweightcalc$wp
df_competitorinfo <- setDT(df_competitorweightcalc)[, .(avgcompLL=sum(avgcompLL),avgcomppricebefore=sum(avgcomppricebefore), avgcompfinalprice=sum(avgcompfinalprice), avgcompdiscount=sum(avgcompdiscount)), .(vecka)]
df_own=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],]
df_own <- merge(df_own,df_competitorinfo, by=c("vecka"))
df_rep[(1+((i-1)*153)):(153+((i-1)*153)),] = df_own
df_rep[(1+((i-1)*153)):(153+((i-1)*153)),2] <- toString(distinctbrandcomplete[i])
}
colnames(df_rep) <- colnames(df_own) #replace empty table column name with the original column name
df_rep[,1] <- df_own[,1] #the vecka infor is not replaced so we have to replace from the original table
df_rep$brand<-as.factor(df_rep$brand)
df_bybrand <- df_rep
remove(list=c("df_competitor","weeklysalesbycompetingbrand", "df_competitorweightcalc","df_competitorinfo","df_own","df_rep"))
```


\newpage
# Time-series pattern of data
We will see the time series of price before discount, final price, and discount and by brand from our samples.

```{r time series plot for price before discout, final price and discount, echo=FALSE}
#If I didnt out comma when I'm subsetting; It is throwing an error of undefined columns because you forgot the comma after defining your objective. Because we want to select the row with a given specific condition
par(mfrow = c(3,3))
for (i in 1:length(distinctbrandcomplete)){
data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],]
plot(data$vecka, data$avgfinalprice, main = (distinctbrandcomplete[i]), xlab = "Week", ylab = "Average final price", col="blue")
plot(data$vecka, data$avgpricebefore, main = distinctbrandcomplete[i], col="green", xlab = "Week", ylab = "Average Price Before Discount")
plot(data$vecka, data$avgdiscount, main = distinctbrandcomplete[i], col="red",  xlab = "Week", ylab = "Average Discount")
}
```


\newpage
# Model-free evidence for absolute relationship
We will explore relationship between price before discount, final price, discount and total sales by brand

```{r simple plot for absolute term with linear regression, echo=FALSE}
#If I didnt out comma when I'm subsetting; It is throwing an error of undefined columns because you forgot the comma after defining your objective. Because we want to select the row with a given specific condition
par(mfrow = c(3,3))
for (i in 1:length(distinctbrandcomplete)){
plot(totalvolume ~ avgfinalprice, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],], main = distinctbrandcomplete[i], col="blue")
abline(lm(totalvolume ~ avgfinalprice, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],]), col="blue")
plot(totalvolume ~ avgpricebefore, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],],
     main = distinctbrandcomplete[i], col="green")
abline(lm(totalvolume ~ avgpricebefore, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],]), col="green")
plot(totalvolume ~ avgdiscount, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],], main = distinctbrandcomplete[i], col="red")
abline(lm(totalvolume ~ avgdiscount, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],]), col="red")
}
```

\newpage
# Explore the lag
Next, we want to see the difference term between time. Hence, we need to create lagged variable (by brand)

```{r generate lag term(s)}
#We have to sort the data in the way that we have the same brand and ascending order row
df_bybrand<-df_bybrand[order(df_bybrand$brand,df_bybrand$vecka),]
#Create Lag(1) of TotalVolume,TotalValue, Price before, Final Price, Discount, LineLength for each brand, AND competitive price&linelength
lag_1 <- function(x, k = 1) head(c(rep(NA, k), x), length(x))
df_bybrand$totalvolume1 <- ave(df_bybrand$totalvolume, df_bybrand$brand, FUN= lag_1)
df_bybrand$totalvalue1 <- ave(df_bybrand$totalvalue, df_bybrand$brand, FUN= lag_1)
df_bybrand$LL1 <- ave(df_bybrand$LL, df_bybrand$brand, FUN= lag_1)
df_bybrand$avgfinalprice1 <- ave(df_bybrand$avgfinalprice, df_bybrand$brand, FUN= lag_1)
df_bybrand$avgpricebefore1 <- ave(df_bybrand$avgpricebefore, df_bybrand$brand, FUN= lag_1)
df_bybrand$avgdiscount1 <- ave(df_bybrand$avgdiscount, df_bybrand$brand, FUN= lag_1)
df_bybrand$avgcompLL1 <- ave(df_bybrand$avgcompLL, df_bybrand$brand, FUN= lag_1)
df_bybrand$avgcompfinalprice1 <- ave(df_bybrand$avgfinalprice, df_bybrand$brand, FUN= lag_1)
df_bybrand$avgcomppricebefore1 <- ave(df_bybrand$avgpricebefore, df_bybrand$brand, FUN= lag_1)
df_bybrand$avgcompdiscount1 <- ave(df_bybrand$avgdiscount, df_bybrand$brand, FUN= lag_1)
#We drop week 0
df_bybrand <- na.omit(df_bybrand)
df_bybrand$dtotalvolume <- df_bybrand$totalvolume-df_bybrand$totalvolume1
df_bybrand$dtotalvalue <- df_bybrand$totalvalue-df_bybrand$totalvalue1
df_bybrand$davgfinalprice <- df_bybrand$avgfinalprice-df_bybrand$avgfinalprice1
df_bybrand$davgpricebefore <- df_bybrand$avgpricebefore-df_bybrand$avgpricebefore1
df_bybrand$davgdiscount <- df_bybrand$avgdiscount-df_bybrand$avgdiscount1

#calculate percentage change
df_bybrand$pdtotalvolume <- (df_bybrand$totalvolume-df_bybrand$totalvolume1)/df_bybrand$totalvolume1
df_bybrand$pdtotalvalue <- (df_bybrand$totalvalue-df_bybrand$totalvalue1)/df_bybrand$totalvalue1
df_bybrand$pdavgfinalprice <- (df_bybrand$avgfinalprice-df_bybrand$avgfinalprice1)/df_bybrand$avgfinalprice1
df_bybrand$pdavgpricebefore <- (df_bybrand$avgpricebefore-df_bybrand$avgpricebefore1)/df_bybrand$avgpricebefore1
#if you calculate using prior discount as denominator could lead to inf so we define them as (percentage change relative to price before discount)
df_bybrand$pdavgdiscount <- (df_bybrand$avgdiscount/df_bybrand$avgpricebefore)-(df_bybrand$avgdiscount1/df_bybrand$avgpricebefore1)
```

\newpage
# Model-free evidence for temporal relative relationship
We will explore relationship between difference of price before discount, final price, discount and total sales by brand. We first explore their absolute relationship and then explore their percentage relationship.

```{r simple plot for absolute and percentage difference, echo=FALSE}
par(mfrow = c(3,3))
#absolute different
for (i in 1:length(distinctbrandcomplete)){
plot(dtotalvolume ~ davgfinalprice, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],], main = distinctbrandcomplete[i], col="blue")
plot(dtotalvolume ~ davgpricebefore, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],], main = distinctbrandcomplete[i], col="green")
plot(dtotalvolume ~ davgdiscount, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],], main = distinctbrandcomplete[i], col="red")
}
#percentage difference
for (i in 1:length(distinctbrandcomplete)){
plot(pdtotalvolume ~ pdavgfinalprice, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],], main = distinctbrandcomplete[i], col="blue")
abline(v= 0, col="black")
abline(h= 0, col="black")
plot(pdtotalvolume ~ pdavgpricebefore, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],], main = distinctbrandcomplete[i], col="green")
abline(v= 0, col="black")
abline(h= 0, col="black")
plot(pdtotalvolume ~ pdavgdiscount, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],], main = distinctbrandcomplete[i], col="red")
abline(v= 0, col="black")
abline(h= 0, col="black")
}
```
\newpage

# Explore data more

We want to see if we have to control for seasonality or holiday
We will explore relationship between difference of price before discount, final price, discount and total sales by brand

```{r Plot time series for sales, echo=FALSE}
par(mfrow = c(3,3))
#print the plot of each brand
for (i in 1:length(distinctbrandcomplete)){
plot(totalvolume ~ vecka, data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],], main = distinctbrandcomplete[i], col="darkblue")
}
```
```{r plot time series with holidays, include=FALSE}
par(mfrow = c(3,3))
#It is tricky to plot several holidays in plot function because ABline doesn't work for factor. Hence, I have to convert the week factor into numerical value and then plot (so you will see that there is a big gap between each year)
holidays <- df_holiday[df_holiday$holiday > 0,] 
holidays <- holidays %>% mutate(vecka=droplevels(vecka))
holidays$vecka <-   as.numeric(as.character(holidays$vecka))
distinctholiday <- unique(holidays$vecka)
df_bybrand_date <- df_bybrand
df_bybrand_date$vecka <-   as.numeric(as.character(df_bybrand_date$vecka))

#print the plot of each brand and abline of each week
for (i in 1:length(distinctbrandcomplete)){

plot(totalvolume ~ vecka, data=df_bybrand_date[df_bybrand_date$brand == distinctbrandcomplete[i],], main = distinctbrandcomplete[i], col="darkblue")
    #create abline for holiday
    for (j in 1:length(distinctholiday)){
    abline(v= distinctholiday[j], col="blue")}
}
remove(list=c("holidays","df_bybrand_date"))
```

```{r merge holiday info, echo=FALSE}
df_bybrand <- merge(df_bybrand,df_holiday[,2:3], by=c("vecka"))
```



\newpage

# Pauwels et al. (2007)


*Estimate sales responses*

From Error-Correction Form
$$\Delta ln(S_{i,t}) = c + \alpha_0\Delta ln(P_{i,t})+\sum_{j=1}^{J-1} \kappa_{j}ln(P_{j,t})+\phi_{1}[ln(S_{i,t-1})-\phi_{2}ln(P_{i,t-1})]+\epsilon_{i,t}$$

**Example of full model (from Koen Pauwels, Shuba Srinivasan and Philip-Hans Franses 2007)**

With 4 brands in the category, an example of a full model that is estimated is: 


$$log(S_{4,t})-log(S_{4,t-1})= c +[\alpha_{0} + \frac{\alpha_{G,HBP}}{1+exp(100(log(P_{4,t})-log(P_{4,t-1})-\beta_{G,HBP})}$$ $$+\frac{\alpha_{L,HBP}}{1+exp(-100(log(P_{4,t})-log(P_{4,t-1})-\beta_{L,HBP})}$$
$$+\frac{\alpha_{G,CBP}}{1+exp(100\frac{P_{4,t}-CP_{t}}{CP_{t}}-\beta_{G,CBP})}$$
$$+\frac{\alpha_{L,CBP}}{1+exp(-100\frac{P_{4,t}-CP_{t}}{CP_{t}}-\beta_{L,CBP})}](log(P_{4,t})-log(P_{4,t-1}))$$
$$\kappa_{1}(log(P_{1,t})-log(P_{1,t-1}))+\kappa_{2}(log(P_{2,t})-log(P_{2,t-1}))+\kappa_{3}(log(P_{3,t})-log(P_{3,t-1}))$$
$$\phi_1log(S_{4,t-1})+\Phi log(P_{4,t-1})+\delta_{1}(Feat_{4})+\delta_{2}(Display_{4})$$
$$+\sum_{s=1}^{12}s_{i}Month_{i} + \sum_{h=1}^{H}h_{h}Holiday_{h}$$


where $\Phi$ is $(\phi_1)(\phi_2)$ and $100$ is $\gamma$ is the smoothness of the transition curve (In Pauwels, Srinivasan and Franses 2007, they set the gamma parameters at the same value of $500$)

\newpage
# Analysis: Working on Final Price (Replicate Pauwels et al. 2009)
* First, we want to replicate Pauwel et al. (2007) by working on the final price. However, as we will work on the discount later in which contains the value of zero. It is more reasonable to work on the unit value as proposed by Hannes et al. (2019).

We will use **Datta et al. (2019) full linear model sales-response model** (an error-correction specification):

$$\Delta(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta (Linelength_{it})+\beta_{2i}\Delta (Price_{it})$$
$$+\beta_{3i}\Delta (CompLinelength_{it})+\beta_{4i}\Delta (CompPrice_{it})$$
$$+\gamma_{i}[S_{i,t-1} - \beta_{5i}Linelength_{i,t-1}-\beta_{6i}Price_{i,t-1}]+\beta_{7i}Trend_{t}+\beta_{8i}Holiday_{t} + Copula$$
where
$$\Delta X_{t} = X_{t} - X_{t-1}$$

* Thus we will employ **likelihood ratio test** for this three model adapted from Datta et al. (2019) above

(1) Linear Model
$$\Delta(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta (Linelength_{it})+\beta_{2i}\Delta (Price_{it}) + ... $$
(2) Linear Model with cross products of $\Delta P_{t}$ with $\Delta P_{t}$, its squares and its cubes
$$\Delta(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta (Linelength_{it})+\beta_{2i}\Delta (Price_{it}) + \beta_{9i}{\Delta (Price_{it})}^2\beta_{10i}{\Delta (Price_{it})}^3... $$
(3) With cross products of $\Delta P_{t}$ with other GAP measure
$$\Delta(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta (Linelength_{it})+\beta_{2i}\Delta (Price_{it}) + \beta_{9i}{\Delta (Price_{it})}^2\beta_{10i}{\Delta (Price_{it})}^3+\beta_{11i}[(GAP)\Delta (Price_{it})]... $$

* P-Value for (non)linearity test is LR test between model (1) and (2)
* P-Value for whether it is particular nonlinear model with either GAP (Historical GAP VS Competitive GAP) is LR test between model (2) and (3)
* We report the results for model comparison tests for benchmark price type and threshold asymmetry for each brand below.
```{r replicate Pauwels with non-log model and test LR, echo=FALSE}
df_bybrand$dLL = df_bybrand$LL - df_bybrand$LL1
df_bybrand$davgcompLL = df_bybrand$avgcompLL - df_bybrand$avgcompLL1
df_bybrand$davgcompfinalprice = df_bybrand$avgcompfinalprice - df_bybrand$avgcompfinalprice1
df_bybrand$gapcompfinalprice = df_bybrand$avgfinalprice-df_bybrand$avgcompfinalprice
  
df_rep_lr <- data.frame(matrix(NA, ncol = 3 , nrow = (nbrand))) 

#Calculate lm for final price and (before-discount)
  for (i in 1:length(distinctbrandcomplete)){
#lm for final price
lm_rep_linear <- lm(dtotalvolume ~ dLL + davgfinalprice + davgcompLL + davgcompfinalprice + totalvolume1 + LL1 +avgfinalprice1 + holiday ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])

#lm with its cross product; square and cub
lm_rep_poly <- lm(dtotalvolume ~ dLL + davgfinalprice + davgcompLL + davgcompfinalprice + totalvolume1 + LL1 +avgpricebefore1 + avgdiscount1 + holiday +I(davgfinalprice^2)+I(davgfinalprice^3),data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])

#lm with gap
lm_rep_gap <- lm(dtotalvolume ~ dLL + (gapcompfinalprice*davgfinalprice)  + davgcompLL + davgcompfinalprice + totalvolume1 + LL1 +avgpricebefore1 + avgdiscount1 + holiday +I(davgfinalprice^2)+I(davgfinalprice^3) ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])

#test likelihood ration of these three models
test_nonlinear<-lrtest(lm_rep_linear, lm_rep_poly)
test_gap<-lrtest(lm_rep_poly, lm_rep_gap)

df_rep_lr[i,1] <- toString(distinctbrandcomplete[i])
df_rep_lr[i,2] = round(test_nonlinear$`Pr(>Chisq)`[2],4) #round number to 4 decimals
df_rep_lr[i,3] = round(test_gap$`Pr(>Chisq)`[2],4)
  }

colnames(df_rep_lr) <- c('brand','p-value for (non)linearity test','p-value for GAP test')
knitr::kable(df_rep_lr, col.names = c('Brand','p-value for (non)linearity test','p-value for GAP test'))
#create decision table with 95% confidence interval or alpha = 0.05
df_rep_decision <- df_rep_lr
df_rep_decision[,2] <- ifelse(df_rep_lr$`p-value for (non)linearity test`< 0.05, 'nonlinear', 'linear')
df_rep_decision[,3] <- ifelse((df_rep_lr$`p-value for GAP test`< 0.05 & df_rep_lr$`p-value for (non)linearity test`< 0.05), 'fullmodel', 'linear or particular nonlinear')
knitr::kable(df_rep_decision, col.names = c('Brand','Linear Decision','GAP Decision'))
```

\newpage
# Working on Price Before Discount and Discount
Initially, we want to test the linear relationship between final price, price before and discount:
$$\alpha_0\Delta ln(P_{final, i,t})=\alpha_0\Delta ln(P_{before, i,t}-Discount_{i,t})$$

Hence we expect;
$$\alpha_{P_{final}}=\alpha_{P_{before}} = \alpha_{Discount}= \alpha_0$$

Again, We will use **datta et al. (2019) full linear model sales-response model** (an error-correction specification):

$$\Delta(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta (Linelength_{it})+\beta_{2i}\Delta (Price_{it})$$
$$+\beta_{3i}\Delta (CompLinelength_{it})+\beta_{4i}\Delta (CompPrice_{it})$$
$$+\gamma_{i}[S_{i,t-1} - \beta_{5i}Linelength_{i,t-1}-\beta_{6i}Price_{i,t-1}]+\beta_{7i}Trend_{t}+\beta_{8i}Holiday_{t} + Copula$$
where
$$\Delta X_{t} = X_{t} - X_{t-1}$$

So, we first run a model
$$(1) \Delta(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta ln(Linelength_{it})+\beta_{2i}\Delta (Final Price_{it})+...$$
and compare to

$$(2) \Delta(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta ln(Linelength_{it})+\beta_{2i}\Delta (Price_{beforeit} )-\beta_{2i}\Delta (Discount_{i,t})+...$$

* In other words, we want to compare $\beta_{2i}$ if they are equal. We use F-Test for linearity assumption. We list the coefficients of final price, price before and discount from (1) and (2) and report the adjusted R-squared of each model (for each brand) and P-value for testing linear hypothesis on the coefficients of a system of equations by an F-test.

```{r Estimate full linear model with table, echo=FALSE}
  df_bybrand$dLL = df_bybrand$LL - df_bybrand$LL1
  df_bybrand$davgcompLL = df_bybrand$avgcompLL - df_bybrand$avgcompLL1
  df_bybrand$davgcompfinalprice = df_bybrand$avgcompfinalprice - df_bybrand$avgcompfinalprice1
  
df_linear_1 <- data.frame(matrix(NA, ncol = 4 , nrow = (nbrand))) 
df_linear_2 <- data.frame(matrix(NA, ncol = 4 , nrow = (nbrand))) 

#Calculate lm for final price and (before-discount)
  for (i in 1:length(distinctbrandcomplete)){
#lm for final price
lm_est_step0_finalprice <- lm(dtotalvolume ~ dLL + davgfinalprice + davgcompLL + davgcompfinalprice + totalvolume1 + LL1 +avgfinalprice1 + holiday ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])

#lm for before&discount
lm_est_step0_pricebefore <- lm(dtotalvolume ~ dLL + davgpricebefore + davgdiscount + davgcompLL + davgcompfinalprice + totalvolume1 + LL1 +avgpricebefore1 + avgdiscount1 + holiday ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])

#test coefficient between price before discount (Testing linear hypothesis on the coefficients of a system of equations by an F-test or Wald-test)
  #see more https://kzee.github.io/CoeffDiff_Demo.html
coeftest<-linearHypothesis(lm_est_step0_pricebefore, "davgpricebefore - davgdiscount = 0")

df_linear_1[i,1] <- toString(distinctbrandcomplete[i])
df_linear_1[i,2] = round(summary(lm_est_step0_finalprice)$coefficients[3],4) #round number to 4 decimals
df_linear_1[i,3] = round(summary(lm_est_step0_pricebefore)$coefficients[3],4)
df_linear_1[i,4] = round(summary(lm_est_step0_pricebefore)$coefficients[4],4)
df_linear_2[i,1] = toString(distinctbrandcomplete[i])
df_linear_2[i,2] = round(summary(lm_est_step0_finalprice)$adj.r.squared,4)
df_linear_2[i,3] = round(summary(lm_est_step0_pricebefore)$adj.r.squared,4)
df_linear_2[i,4] = round(coeftest$`Pr(>F)`[2],4)
  }

colnames(df_linear_1) <- c('brand','Coef FinalP','Coef PBefore','Coef Discount')

colnames(df_linear_2) <- c('brand','R2 of final price model','R2 of Pbefore and discount model', 'P-Value of testing linear hypothesis')

knitr::kable(df_linear_1, col.names = c('Brand','Coef FinalP','Coef PBefore','Coef Discount')) #kable from knitr. It will format the table nicely. see more https://bookdown.org/yihui/rmarkdown-cookbook/kable.html
knitr::kable(df_linear_2, col.names = c('Brand','R2 of final price model','R2 of Pbefore and discount model', 'P-Value of testing linear hypothesis'))

remove(list=c("lm_est_step0_finalprice","lm_est_step0_pricebefore","coeftest"))
```


* We have tried implementing log-log model but we got a problem when running with log-log specification as our discount can be zero and that make log0 becomes NaN. (Log0 is undefined. It's not a real number, because you can never get zero by raising anything to the power of anything else.) So, a linear model is used to avoid the aggregation bias that would occur when working with, for example, a log-log specification.

```{r Estimate full linear (log-log) model, eval=FALSE, include=FALSE}
  df_bybrand$dlogtotalvolume = log(df_bybrand$totalvolume)-log(df_bybrand$totalvolume1)
  df_bybrand$dlogLL = log(df_bybrand$LL) - log(df_bybrand$LL1)
  df_bybrand$dlogavgfinalprice = log(df_bybrand$avgfinalprice) - log(df_bybrand$avgfinalprice1)
  df_bybrand$dlogavgpricebefore = log(df_bybrand$avgpricebefore) - log(df_bybrand$avgpricebefore1)
  df_bybrand$dlogavgdiscount = log(df_bybrand$avgdiscount) - log(df_bybrand$avgdiscount1)
  df_bybrand$dlogavgcompLL = log(df_bybrand$avgcompLL) - log(df_bybrand$avgcompLL1)
  df_bybrand$dlogavgcompfinalprice = log(df_bybrand$avgcompfinalprice) - log(df_bybrand$avgcompfinalprice1)


#Calculate lm for final price and (before-discount)
  for (i in 1:length(distinctbrandcomplete)){
#lm for final price
lmlog_est_step0_finalprice <- lm(dlogtotalvolume ~ dlogLL + dlogavgfinalprice + dlogavgcompLL + dlogavgcompfinalprice + log(totalvolume1) + log(LL1) + log(avgfinalprice1) + holiday ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])
message(paste("Brand:", distinctbrandcomplete[i]))
message(paste("Coefficient of final price:", summary(lmlog_est_step0_finalprice)$coefficients[3])) #print coefficient of final price

#lm for before&discount
lmlog_est_step0_pricebefore <- lm(dlogtotalvolume ~ dLL + dlogavgpricebefore + dlogavgdiscount + dlogavgcompLL + dlogavgcompfinalprice + log(totalvolume1) + log(LL1) + log(avgpricebefore1) + log(avgdiscount1) + holiday ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])

#test coefficient between price before discount (Testing linear hypothesis on the coefficients of a system of equations by an F-test or Wald-test)
  #see more https://kzee.github.io/CoeffDiff_Demo.html
coeftest<-linearHypothesis(lmlog_est_step0_pricebefore, "davgpricebefore - davgdiscount = 0")

message(paste("Coefficient of price before:", summary(lmlog_est_step0_pricebefore)$coefficients[3]))
message(paste("Coefficient of discount:", summary(lmlog_est_step0_pricebefore)$coefficients[4]))
message(paste("Rsquared of final price model:", summary(lmlog_est_step0_finalprice)$r.squared))
message(paste("Rsquared of price before and discount model:", summary(lmlog_est_step0_pricebefore)$r.squared))
message(paste("P-Value of testing linear hypothesis on the price before and discount coefficients:", coeftest$`Pr(>F)`[2]))
}
```

* We try to explore more by running linear model from previous section or model (2) without interaction and with interaction between discount and price (model 3). 
(2)
$$\Delta(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta ln(Linelength_{it})+\beta_{2i}\Delta (Price_{beforeit} )-\beta_{2i}\Delta (Discount_{i,t})+...$$
(3)
$$\Delta(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta ln(Linelength_{it})+\beta_{2i}\Delta (Price_{beforeit} )-\beta_{2i}\Delta (Discount_{i,t})+ \beta_{9i}(\Delta (Price_{beforeit})(\Delta (Discount_{i,t})) + ...$$

* We reported the adjusted R-squared of model (2) and (3) respectively.

```{r Estimate full linear model with interaction, echo=FALSE}
df_interaction <- data.frame(matrix(NA, ncol = 3 , nrow = (nbrand))) 
#Calculate lm for final price and (before-discount)
  for (i in 1:length(distinctbrandcomplete)){
#lm for before&discount with interaction
lm_est_step0_pricebefore_withoutinter <- lm(dtotalvolume ~ dLL + davgpricebefore + davgdiscount + davgcompLL + davgcompfinalprice + totalvolume1 + LL1 +avgpricebefore1 + avgdiscount1 + holiday ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])    
lm_est_step0_pricebefore_withinteraction <- lm(dtotalvolume ~ dLL + davgpricebefore*davgdiscount + davgcompLL + davgcompfinalprice + totalvolume1 + LL1 +avgpricebefore1 + avgdiscount1 + holiday ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])
df_interaction[i,1] <- toString(distinctbrandcomplete[i])
df_interaction[i,2] = round(summary(lm_est_step0_pricebefore_withoutinter)$adj.r.squared,4) 
df_interaction[i,3] = round(summary(lm_est_step0_pricebefore_withinteraction)$adj.r.squared,4)
  }

colnames(df_interaction) <- c('brand','R2without','R2With')
knitr::kable(df_interaction, col.names = c('Brand','R2 of Model Without Interaction','R2 of Model With Interaction'))

remove(list=c("lm_est_step0_pricebefore_withoutinter","lm_est_step0_pricebefore_withinteraction"))
```

* We extend our model (2) by adding its cross product of $\Delta P_{t}$ with $\Delta P_{t}$; its square and its cubes to see if there is any evidence of linearity. Hence we add ${\Delta PBefore_{t}}^2,{\Delta Discount_{t}}^2,{\Delta PBefore_{t}}^3,{\Delta Discount_{t}}^3$. We reported adjusted R-squared of this model (model (4)).

(4)
$$\Delta(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta ln(Linelength_{it})+\beta_{2i}\Delta (Price_{beforeit} )-\beta_{2i}\Delta (Discount_{i,t})$$
$$ + \beta_{9i}{\Delta (Price_{it})}^2\beta_{10i}{\Delta (Price_{it})}^3+ \beta_{11i}{\Delta (Discount_{it})}^2\beta_{12i}{\Delta (Discount_{it})}^3+...$$

* We reported adjusted R-squared of this model.

```{r Estimate linear model with its square and its cube, echo=FALSE}
df_sqrcub <- data.frame(matrix(NA, ncol = 2 , nrow = (nbrand)))
#Calculate lm with square and cube for price before and discount
  for (i in 1:length(distinctbrandcomplete)){
#lm for before&discount with its square and cube
lm_est_step1 <- lm(dtotalvolume ~ dLL + davgpricebefore + davgdiscount + davgcompLL + davgcompfinalprice + totalvolume1 + LL1 +avgpricebefore1 + avgdiscount1 + holiday +I(davgpricebefore^2)+I(davgpricebefore^3)+I(davgdiscount^2)+I(davgdiscount^3) ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])

df_sqrcub[i,1] <- toString(distinctbrandcomplete[i])
df_sqrcub[i,2] = round(summary(lm_est_step1)$adj.r.squared,4) 
  }

colnames(df_sqrcub) <- c('brand','R2')
knitr::kable(df_sqrcub, col.names = c('Brand','Adjusted Rsquared of model with square and cube'))

remove(list=c("lm_est_step1"))
```

* We extend our model (4) by adding GAP measures including 1) `Gap with Historical benchmark price(before)` 2) `Gap with Competitive benchmark price(before)` 3)`Gap with Historical benchmark discount` and 4) `Gap with Competitive benchmark Discount`. 

(5)
$$\Delta(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta ln(Linelength_{it})+\beta_{2i}\Delta (Price_{beforeit} )-\beta_{2i}\Delta (Discount_{i,t})$$
$$ + \beta_{9i}{\Delta (Price_{it})}^2\beta_{10i}{\Delta (Price_{it})}^3+ \beta_{11i}{\Delta (Discount_{it})}^2\beta_{12i}{\Delta (Discount_{it})}^3$$
$$ + \beta_{13i}[(GAPPrice)\Delta (Price_{it})]+ \beta_{14i}[(GAPDiscount)\Delta (Discount_{it})] +...$$

* We reported adjusted R-squared of this model.

```{r Estimate linear model with GAP measure, echo=FALSE}
  #create gap measure for CBP (as HBP is already davgpricebefore and davgdiscount)
  df_bybrand$gapcomppricebefore = df_bybrand$avgpricebefore-df_bybrand$avgcomppricebefore
  df_bybrand$gapcompdisc = df_bybrand$avgdiscount-df_bybrand$avgcompdiscount

df_gap <- data.frame(matrix(NA, ncol = 2 , nrow = (nbrand)))
#Calculate lm with square and cube for price before and discount
  for (i in 1:length(distinctbrandcomplete)){
#lm for before&discount with its square and cube
lm_est_step1_gap <- lm(dtotalvolume ~ dLL + (gapcomppricebefore*davgpricebefore) + (gapcompdisc*davgdiscount) + davgcompLL + davgcompfinalprice + totalvolume1 + LL1 +avgpricebefore1 + avgdiscount1 + holiday +I(davgpricebefore^2)+I(davgpricebefore^3)+I(davgdiscount^2)+I(davgdiscount^3) ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])

df_gap[i,1] <- toString(distinctbrandcomplete[i])
df_gap[i,2] = round(summary(lm_est_step1_gap)$adj.r.squared,4) 
  }

colnames(df_sqrcub) <- c('brand','R2')
knitr::kable(df_sqrcub, col.names = c('Brand','Adjusted Rsquared of model with GAP measures'))

remove(list=c("lm_est_step1_gap"))
```

We then follow the criteria described by Pauwels et al. (2007) by using likelihood ratio test for linearity model comparing model (2), model(4) with cross products and model (5) with GAP measures. In case one of the LR tests is significant, we proceed with that particular nonlinear model. If both tests are significant, we proceed with the model with both HBP (Historical Benchmark Price Gap) and CBP (Competitive Benchmark Price Gap) (with transition function)

```{r LR test between (1)Linear model (2) Linear with square and cube and (3) linear with square, cube and gap, echo=FALSE}

  #see more https://api.rpubs.com/tomanderson_34/lrt

df_lr <- data.frame(matrix(NA, ncol = 3 , nrow = (nbrand))) 

  for (i in 1:length(distinctbrandcomplete)){
#lm linear
lm_1 <- lm(dtotalvolume ~ dLL + (gapcomppricebefore*davgpricebefore) + (gapcompdisc*davgdiscount) + davgcompLL + davgcompfinalprice + totalvolume1 + LL1 +avgpricebefore1 + avgdiscount1 + holiday +I(davgpricebefore^2)+I(davgpricebefore^3)+I(davgdiscount^2)+I(davgdiscount^3) ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])
#lm with square and cube
lm_2 <- lm(dtotalvolume ~ dLL + davgpricebefore + davgdiscount + davgcompLL + davgcompfinalprice + totalvolume1 + LL1 +avgpricebefore1 + avgdiscount1 + holiday +I(davgpricebefore^2)+I(davgpricebefore^3)+I(davgdiscount^2)+I(davgdiscount^3) ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])
#lm with gap
lm_3 <- lm(dtotalvolume ~ dLL + (gapcomppricebefore*davgpricebefore) + (gapcompdisc*davgdiscount) + davgcompLL + davgcompfinalprice + totalvolume1 + LL1 +avgpricebefore1 + avgdiscount1 + holiday +I(davgpricebefore^2)+I(davgpricebefore^3)+I(davgdiscount^2)+I(davgdiscount^3) ,data=df_bybrand[df_bybrand$brand == distinctbrandcomplete[i],])
test_nonlinear<-lrtest(lm_1, lm_2)
test_gap<-lrtest(lm_2, lm_3)

df_lr[i,1] <- toString(distinctbrandcomplete[i])
df_lr[i,2] = round(test_nonlinear$`Pr(>Chisq)`[2],4) #round number to 4 decimals
df_lr[i,3] = round(test_gap$`Pr(>Chisq)`[2],4)
  }
colnames(df_lr) <- c('brand','p-value for (non)linearity test','p-value for GAP test')
knitr::kable(df_lr, col.names = c('Brand','p-value for (non)linearity test','p-value for GAP test'))

#create decision table with 95% confidence interval or alpha = 0.05
df_decision <- df_lr
df_decision[,2] <- ifelse(df_lr$`p-value for (non)linearity test`< 0.05, 'nonlinear', 'linear')
df_decision[,3] <- ifelse((df_rep_lr$`p-value for GAP test`< 0.05 & df_rep_lr$`p-value for (non)linearity test`< 0.05), 'fullmodel', 'linear or particularnonlinear')


knitr::kable(df_decision, col.names = c('Brand','Linear Decision','GAP Decision'))
remove(list=c("lm_1","lm_2","lm_3"))
```


\newpage
# Analysis: Implementing Non-Linear Model

## Working on Final Price (Replicating Pauwels et al. 2007)

* We select the brand that may fit better with nonlinear model from previous step.

```{r select brand nonlinear final price}
brand_rep_fullmodel <- unique(as.factor(df_rep_decision[df_rep_lr$`p-value for (non)linearity test`< 0.05 & df_rep_lr$`p-value for GAP test` < 0.05,]$brand))
brand_rep_particularnon <- unique(as.factor(df_rep_decision[df_rep_lr$`p-value for (non)linearity test`< 0.05 & df_rep_lr$`p-value for GAP test` > 0.05,]$brand))
brand_rep_nonlinear <- unique(as.factor(df_rep_decision[df_rep_lr$`p-value for (non)linearity test`< 0.05,]$brand))
```

* We want to replicate the test results for nonlinearity as illustrated in Table B.1 (Appendix B) in Pauwels et al. (2007)

## Working on Price Before and Discount
