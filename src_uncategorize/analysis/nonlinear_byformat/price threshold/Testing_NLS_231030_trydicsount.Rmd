---
title: "Estimating Non Linear Threshold for Selected Brands by Least Square Method"
output: html_notebook
---

We import Ramlosa at Supermarket datasets that has statistical evidence for "historical price gap"

```{r load relevant library}
library(dplyr) #for mutate factor
library(data.table) #turning results in table
```

```{r import dataset}
df_his <- read.csv("../../../../src/analysis/nonlinear_byformat/price threshold/ramlosa_super_histgap.csv")
df_his <- df_his %>% mutate(vecka=droplevels(as.factor(vecka))) 

df_full <- read.csv("../../../../src/analysis/nonlinear_byformat/price threshold/loka_super_fullgap.csv")
df_full <- df_full %>% mutate(vecka=droplevels(as.factor(vecka))) 
```

\section{Without Competitive Price}

Model Free Evidence Between Price and Sales
```{r plot price and sales for ramlosa, echo=TRUE}
plot(df_his$vecka, df_his$avgfinalprice, main = "Ramlosa Price in Supermarket", xlab = "Week", ylab = "Average final price", col="blue")

plot(df_his$totalvolume ~ df_his$avgfinalprice, main = "Ramlosa Price & Sales (Vol) in Supermarket", col="blue")
abline(lm(df_his$totalvolume ~ df_his$avgfinalprice), col="blue")

hist(df_his$dlogavgfinalprice)

summary(df_his$dlogavgfinalprice)
```

(1) Simple Model to calculate error (correction) term: $$ (1) ln(S_{i,t-1}) = a_{0i}+a_{1i}ln(P_{it-1}) + e_{it} $$ 

(0) Calculate Linear Model to get initial value for optimization
$$ \Delta ln(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta (P_{it})+ \phi_1[ln(S_{i,t-1})-\phi_2 ln(P_{i,t-1}))] $$

```{r linear model}
lm_his_linear <- lm(dlogtotalvolume ~ dlogavgfinalprice + log(totalvolume1) + log(avgfinalprice1) ,data=df_his)

summary(lm_his_linear)


c_his_lm <- summary(lm_his_linear)$coefficients[1,1]
alpha_0_his_lm <- summary(lm_his_linear)$coefficients[2,1]
phi_1_his_lm <- summary(lm_his_linear)$coefficients[3,1]
phi_2_his_lm <- (summary(lm_his_linear)$coefficients[4,1])/(summary(lm_his_linear)$coefficients[3,1]) # this coef = phi1*phi2

paste("Initial Value for constant term:", c_his_lm) 
paste("Initial Value for base elasticity:", alpha_0_his_lm) 
paste("Initial Value for phi1:", phi_1_his_lm) 
paste("Initial Value for phi2:", phi_2_his_lm) #should be positive?
```
Objective: We want to estimate nonlinear model with historical price gap:
$$\Delta ln(S_{i,t}) = c +\{\alpha_{0}
 + \frac{\alpha_{HG}}{1+exp(\gamma(HistPGap_{i,t}))-b_{HG})} +\frac{\alpha_{HL}}{1+exp(-\gamma(HistPGap_{i,t}))-b_{HL})}\}\Delta ln(P_{i,t})\\ 
+ \phi_1[ln(S_{i,t-1})+\phi_2 ln(P_{i,t-1}))]$$


We will obtain initial value of thresholds ($\beta_G,\beta_L$)  from distribution of $\Delta (P_{it}$ and change of slope by moderate change ($\alpha_G,\alpha_L$) and assume symmetrical case.

```{r assume alpha and beta}
alpha_g_his_lm <- -0.25
alpha_l_his_lm <- 0.25

beta_l_his_lm <- mean(df_his$dlogavgfinalprice) + sd(df_his$dlogavgfinalprice)
beta_g_his_lm <- -beta_l_his_lm

paste("Initial Value for change slope gain (alphaG):", alpha_g_his_lm) 
paste("Initial Value for change slope loss (alphaL):", alpha_l_his_lm) 
paste("Initial Value for threshold gain (betaG):", beta_g_his_lm) 
paste("Initial Value for threshold loss (betaL):", beta_l_his_lm) #should be positive?
```


Then, we estimate using least square method (minimizing SSE)

```{r Estimate with NLS (Histgap)}

LS_nonlinear_his <- function(parvec){
  
  F_H_G <- 1/(1+exp(gamma*(df_his$hgap - parvec[4])))
  F_H_L <- 1/(1+exp(-gamma*(df_his$hgap - parvec[6])))
  

  ut <- df_his$dlogtotalvolume - (parvec[1] + (parvec[2] 
                                         + parvec[3]*F_H_G + parvec[5]*F_H_L)*df_his$dlogavgfinalprice 
                            + parvec[7]*((log(df_his$totalvolume1))+parvec[8]*log(df_his$avgfinalprice1)))
  SSE <- sum(ut^2)
  return(SSE)
}

  gamma <- 500 #assumed

  parvec_1 <- c_his_lm
  parvec_2 <- alpha_0_his_lm
  parvec_3 <- alpha_g_his_lm
  parvec_4 <- beta_g_his_lm 
  parvec_5 <- alpha_l_his_lm 
  parvec_6 <-  beta_l_his_lm 
  parvec_7 <- phi_1_his_lm
  parvec_8 <- phi_2_his_lm
  

Start_v_LS <- c(parvec_1,parvec_2,parvec_3,parvec_4,parvec_5,parvec_6,parvec_7,parvec_8)

  n <- dim(df_his)[1]
  k <- length(Start_v_LS)


LS_logL_nonlinear_his_constraint = optim(Start_v_LS,
                  fn = LS_nonlinear_his, # function to maximize
                  method = "BFGS",
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  )

MSE_calculated <- LS_logL_nonlinear_his_constraint$value/(n-k)

paste("Calculated SE of model:",MSE_calculated)

par_LS.est<-LS_logL_nonlinear_his_constraint$par
OI<-solve(LS_logL_nonlinear_his_constraint$hessian)
par_LS.se<-sqrt(diag(OI))

Start_v_LS
par_LS.est

par_LS_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_gain_threshold","hgap_loss_slope","hgap_loss_threshold",
                   "correction_1","correction_2")
par_LS <- data.table(cbind(par_LS_name,par_LS.est,par_LS.se))
par_LS$tstat <- as.numeric(par_LS$par_LS.est)/as.numeric(par_LS$par_LS.se)

par_LS 
```

Plot
```{r plot result from LS}
c_0 <- par_LS.est[1]
alpha0 <- par_LS.est[2]
alpha_G <- par_LS.est[3]
beta_G <- par_LS.est[4]
alpha_L <- par_LS.est[5]
beta_L <- par_LS.est[6]
phi_1_his <- par_LS.est[7]
phi_2_his <- par_LS.est[8]

# Defining x-values
graph_reso <- 0.01
x_values <- seq(min(df_his$dlogavgfinalprice), max(df_his$dlogavgfinalprice), by = graph_reso)
xgap_values <- seq(min(df_his$hgap), max(df_his$hgap), by = graph_reso)


# Defining various functions to plot
NLPE <- function(dlogavgfinalprice,hgap)
      {( alpha0 + alpha_G*( 1 + exp(gamma*(hgap-beta_G) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap-beta_L) ) )^-1 )*dlogavgfinalprice}
TransF <- function(hgap){alpha0 + alpha_G*( 1 + exp(gamma*(hgap-beta_G) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap-beta_L)))^-1}

F_G <- function(x){( 1 + exp( gamma*(hgap-beta_G) ) )^-1}
F_L <- function(x){( 1 + exp( -gamma*(hgap-beta_L) ) )^-1}

NLPE_values <- NLPE(dlogavgfinalprice=x_values,hgap=xgap_values)
TransF_values <- TransF(hgap=xgap_values)
time <- seq(1:151)

#Plot
plot(x_values, NLPE_values, type = "l", main = "Nonlinear price elasticities Ramlosa", xlab = "dlogavgfinalprice", ylab = "NLPE")
plot(xgap_values, TransF_values, type = "l", main = "Smooth Transition Functions", xlab = "hispricegap", ylab = "STF")
```

```{r plot linear vs nonlinear}
linear_predict <- function(dlogavgfinalprice,totalvolume1,avgfinalprice1){
  c_his_lm + alpha_0_his_lm*dlogavgfinalprice + phi_1_his_lm*log(totalvolume1) + (phi_1_his_lm*phi_2_his_lm)*log(avgfinalprice1)
  }

nonlinear_predict <- function(dlogavgfinalprice,hgap,totalvolume1,avgfinalprice1)
{c_0 +(alpha0 + alpha_G*( 1 + exp(gamma*(hgap-beta_G) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap-beta_L) ) )^-1 )*dlogavgfinalprice + phi_1_his*(log(df_his$totalvolume1))+(phi_1_his*phi_2_his*log(df_his$avgfinalprice1))}

pre_linear <- cbind(linear_predict(dlogavgfinalprice=df_his$dlogavgfinalprice,totalvolume1 = df_his$totalvolume1,avgfinalprice1 = df_his$avgfinalprice1),df_his$dlogavgfinalprice,c("linear"))

pre_nonlinear<- cbind(nonlinear_predict(dlogavgfinalprice=df_his$dlogavgfinalprice,hgap=df_his$dlogavgfinalprice,totalvolume1 = df_his$totalvolume1,avgfinalprice1 = df_his$avgfinalprice1),df_his$dlogavgfinalprice,c("nonlinear"))

actual <- cbind(df_his$dlogtotalvolume,df_his$dlogavgfinalprice,c("actual"))

compare_actual_predict <- rbind(actual,pre_linear,pre_nonlinear)


plot(compare_actual_predict[,2], compare_actual_predict[,1], pch = 19,col = factor(compare_actual_predict[,3]),
     xlab="dlogPrice", ylab="dlogTotalVolume")
legend("topright",
       legend = levels(factor(compare_actual_predict[,3])),
       pch = 19,
       col = factor(levels(factor(compare_actual_predict[,3]))))
```
```{r check}
linear_predict <- function(dlogavgfinalprice){alpha_0_his_lm*dlogavgfinalprice}

nonlinear_predict <- function(dlogavgfinalprice,hgap)
{(alpha0 + alpha_G*( 1 + exp(gamma*(hgap-beta_G) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap-beta_L) ) )^-1 )*dlogavgfinalprice}

pre_linear <- cbind(linear_predict(dlogavgfinalprice=df_his$dlogavgfinalprice),df_his$dlogavgfinalprice,c("linear"))

pre_nonlinear<- cbind(nonlinear_predict(dlogavgfinalprice=df_his$dlogavgfinalprice,hgap=df_his$dlogavgfinalprice),df_his$dlogavgfinalprice,c("nonlinear"))


compare_actual_predict <- rbind(pre_linear,pre_nonlinear)


plot(compare_actual_predict[,2], compare_actual_predict[,1], pch = 19,col = factor(compare_actual_predict[,3]),
     xlab="dlogPrice", ylab="PriceEffect")
legend("topright",
       legend = levels(factor(compare_actual_predict[,3])),
       pch = 19,
       col = factor(levels(factor(compare_actual_predict[,3]))))

```
## Try 2 benchmarks 

```{r plot price and sales for loka, echo=TRUE}
plot(df_full$vecka, df_full$avgfinalprice, main = "Loka Price in Supermarket", xlab = "Week", ylab = "Average final price", col="blue")

plot(df_full$totalvolume ~ df_full$avgfinalprice, main = "Loka Price & Sales (Vol) in Supermarket", col="blue")
abline(lm(df_full$totalvolume ~ df_full$avgfinalprice), col="blue")

hist(df_full$dlogavgfinalprice)

summary(df_full$dlogavgfinalprice)

hist(df_full$dlogavgfinalprice)

summary(df_full$dlogavgfinalprice)

hist(df_full$cgap)

summary(df_full$cgap)


hist(df_full$dlogavgpricebefore)
hist(df_full$dlognondepth)
```

```{r linear model loka}
lm_full_linear <- lm(dlogtotalvolume ~ dlogavgpricebefore + dlognondepth + log(totalvolume1) + log(avgfinalprice1) ,data=df_full)

summary(lm_full_linear)


c_full_lm <- summary(lm_full_linear)$coefficients[1,1]
alpha_0_full_lm <- summary(lm_full_linear)$coefficients[2,1]
alpha_0_disc_lm <- summary(lm_full_linear)$coefficients[3,1]
phi_1_full_lm <- summary(lm_full_linear)$coefficients[4,1]
phi_2_full_lm <- (summary(lm_full_linear)$coefficients[5,1])/(summary(lm_full_linear)$coefficients[3,1]) # tfull coef = phi1*phi2
alpha_g_his_full_lm <- 0
alpha_l_his_full_lm <- 0

beta_l_his_full_lm <- as.numeric(summary(df_full$dlogavgpricebefore)[3])
beta_g_his_full_lm <- as.numeric(summary(df_full$dlogavgpricebefore)[1])


alpha_g_disc_full_lm <- 0
alpha_l_disc_full_lm <- 0

beta_l_disc_full_lm <- as.numeric(summary(df_full$dlognondepth)[3])
beta_g_disc_full_lm <- as.numeric(summary(df_full$dlognondepth)[1])



LS_nonlinear_full <- function(parvec){
  
  F_H_G <- 1/(1+exp(gamma*(df_full$dlogavgpricebefore - parvec[4])))
  F_H_L <- 1/(1+exp(-gamma*(df_full$dlogavgpricebefore - parvec[6])))
  
  F_D_G <- 1/(1+exp(gamma*(df_full$dlognondepth - parvec[9])))
  F_D_L <- 1/(1+exp(-gamma*(df_full$dlognondepth - parvec[11])))
  
  
  ut <- df_full$dlogtotalvolume - (parvec[1] + (parvec[2] + parvec[3]*F_H_G + parvec[5]*F_H_L)*df_full$dlogavgfinalprice 
                                   +(parvec[7] + parvec[8]*F_D_G + parvec[10]*F_D_L)*df_full$dlognondepth 
                            + parvec[12]*((log(df_full$totalvolume1))+parvec[13]*log(df_full$avgfinalprice1)))
  
  transform_parvec_se <- abs(parvec[14])
  
  logL <- sum (-0.5* log(transform_parvec_se) - 0.5*ut^2/transform_parvec_se)
  return(-logL)
}

  gamma <- 500 #assumed

  parvec_1 <- c_full_lm
  parvec_2 <- alpha_0_full_lm
  parvec_3 <- alpha_g_his_full_lm
  parvec_4 <- beta_l_his_full_lm
  parvec_5 <- alpha_l_his_full_lm
  parvec_6 <-  beta_g_disc_full_lm
  parvec_7 <-  alpha_0_disc_lm
  parvec_8 <- alpha_g_disc_full_lm
  parvec_9 <- beta_g_disc_full_lm 
  parvec_10 <- alpha_l_disc_full_lm 
  parvec_11 <-  beta_l_disc_full_lm 
  parvec_12 <- phi_1_full_lm
  parvec_13 <- phi_2_full_lm
  parvec_14 <- 0.25

Start_v_LS <- c(parvec_1,parvec_2,parvec_3,parvec_4,parvec_5,parvec_6,parvec_7,parvec_8,parvec_9,parvec_10,parvec_11,parvec_12,parvec_13,parvec_14)


  n <- dim(df_full)[1]
  k <- length(Start_v_LS)


LS_logL_nonlinear_full_constraint = optim(Start_v_LS,
                  fn = LS_nonlinear_full, # function to maximize
                  method = "BFGS",
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  )

MSE_calculated <- LS_logL_nonlinear_full_constraint$value/(n-k)

paste("Calculated SE of model:",MSE_calculated)

par_LS.est<-LS_logL_nonlinear_full_constraint$par
OI<-solve(LS_logL_nonlinear_full_constraint$hessian)
par_LS.se<-sqrt(diag(OI))

Start_v_LS
par_LS.est

par_LS_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_gain_threshold","hgap_loss_slope","hgap_loss_threshold",
                   "correction_1","correction_2")
par_LS <- data.table(cbind(par_LS_name,par_LS.est,par_LS.se))
par_LS$tstat <- as.numeric(par_LS$par_LS.est)/as.numeric(par_LS$par_LS.se)

par_LS 



LS_nonlinear_full <- function(parvec){
  F_H_G <- 1/(1+exp(gamma*(dlogavgpricebefore - parvec[4])))
  F_H_L <- 1/(1+exp(-gamma*(dlogavgpricebefore - parvec[6])))
  
  F_D_G <- 1/(1+exp(gamma*(dlognondepth - parvec[9])))
  F_D_L <- 1/(1+exp(-gamma*(dlognondepth - parvec[11])))
  
  parvec[1] + (parvec[2] + parvec[3]*F_H_G + parvec[5]*F_H_L)*dlogavgfinalprice 
                                   +(parvec[7] + parvec[8]*F_D_G + parvec[10]*F_H_L)*dlognondepth 
                            + parvec[12]*((log(totalvolume1))+parvec[13]*log(avgfinalprice1))
}

m.sinexp <- nls(y ~ exp.eq(x, a, b), data = df, start = list(a = 1, b = 1), 
    trace = T)
```

```{r assume alpha and beta loka}
alpha_g_his_full_lm <- -0.25
alpha_l_his_full_lm <- 0.25

beta_l_his_full_lm <- mean(df_full$dlogavgfinalprice) + sd(df_full$dlogavgfinalprice)
beta_g_his_full_lm <- -beta_l_his_full_lm

paste("Initial Value for change slope gain in historical price gap (alphaG):", alpha_g_his_full_lm) 
paste("Initial Value for change slope loss in historical price gap (alphaL):", alpha_l_his_full_lm) 
paste("Initial Value for threshold gain in historical price gap (betaG):", beta_g_his_full_lm) 
paste("Initial Value for threshold loss in historical price gap (betaL):", beta_l_his_full_lm)

alpha_g_comp_full_lm <- 0
alpha_l_comp_full_lm <- 0

beta_l_comp_full_lm <- -0.0001
beta_g_comp_full_lm <- (mean(df_full$cgap) + sd(df_full$cgap))

paste("Initial Value for change slope gain in competitive price gap (alphaG):", alpha_g_comp_full_lm) 
paste("Initial Value for change slope loss in competitive price gap (alphaL):", alpha_l_comp_full_lm) 
paste("Initial Value for threshold gain in competitive price gap (betaG):", beta_g_comp_full_lm) 
paste("Initial Value for threshold loss in competitive price gap (betaL):", beta_l_comp_full_lm)
```

```{r Estimate with NLS (HistCompgap)}

stage0_LS_nonlinear_full <- function(parvec){
  
  F_H_G <- 1/(1+exp(gamma*(df_full$hgap - parvec[4])))
  F_H_L <- 1/(1+exp(-gamma*(df_full$hgap - parvec[6])))
  
  
  ut <- df_full$dlogtotalvolume - (parvec[1] + (parvec[2] 
                                         + parvec[3]*F_H_G + parvec[5]*F_H_L)*df_full$dlogavgfinalprice 
                            + parvec[7]*((log(df_his$totalvolume1))+parvec[8]*log(df_his$avgfinalprice1)))
  SSE <- sum(ut^2)
  return(SSE)
}

  gamma <- 500 #assumed

  parvec_1 <- c_full_lm
  parvec_2 <- alpha_0_full_lm
  parvec_3 <- alpha_g_his_full_lm
  parvec_4 <- beta_g_his_full_lm 
  parvec_5 <- alpha_l_his_full_lm 
  parvec_6 <-  beta_l_his_full_lm 
  parvec_7 <- phi_1_full_lm
  parvec_8 <- phi_2_full_lm
  

stage0_Start_v_LS <- c(parvec_1,parvec_2,parvec_3,parvec_4,parvec_5,parvec_6,parvec_7,parvec_8)

  n <- dim(df_full)[1]
  k <- length(Start_v_LS)


stage0LS_logL_nonlinear_full_constraint = optim(Start_v_LS,
                  fn = stage0_LS_nonlinear_full, # function to maximize
                  method = "BFGS",
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  )

stage0_par_LS.est<-stage0LS_logL_nonlinear_full_constraint$par



LS_nonlinear_full <- function(parvec){
  
  F_H_G <- 1/(1+exp(gamma*(df_full$hgap - parvec[4])))
  F_H_L <- 1/(1+exp(-gamma*(df_full$hgap - parvec[6])))
  
  F_C_G <- 1/(1+exp(gamma*(df_full$cgap - parvec[8])))
  F_C_L <- 1/(1+exp(-gamma*(df_full$cgap - parvec[10])))
  
  
  ut <- df_full$dlogtotalvolume - (parvec[1] + (parvec[2] 
                                         + parvec[3]*F_H_G + parvec[5]*F_H_L
                                         + parvec[7]*F_C_G + parvec[9]*F_C_L)*df_full$dlogavgfinalprice 
                            + parvec[11]*((log(df_his$totalvolume1))+parvec[12]*log(df_his$avgfinalprice1)))
  SSE <- sum(ut^2)
  return(SSE)
}

  gamma <- 500 #assumed

  parvec_1 <- c_full_lm
  parvec_2 <- alpha_0_full_lm
  parvec_3 <- stage0_par_LS.est[3]
  parvec_4 <- stage0_par_LS.est[4]
  parvec_5 <- stage0_par_LS.est[5]
  parvec_6 <-  stage0_par_LS.est[6]
  parvec_7 <- alpha_g_comp_full_lm
  parvec_8 <- beta_g_comp_full_lm 
  parvec_9 <- alpha_l_comp_full_lm 
  parvec_10 <-  beta_l_comp_full_lm 
  parvec_11 <- phi_1_full_lm
  parvec_12 <- phi_2_full_lm
  

Start_v_LS <- c(parvec_1,parvec_2,parvec_3,parvec_4,parvec_5,parvec_6,parvec_7,parvec_8,parvec_9,parvec_10,parvec_11,parvec_12)


  n <- dim(df_full)[1]
  k <- length(Start_v_LS)


LS_logL_nonlinear_full_constraint = optim(Start_v_LS,
                  fn = LS_nonlinear_full, # function to maximize
                  method = "BFGS",
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  )

MSE_calculated <- LS_logL_nonlinear_full_constraint$value/(n-k)

paste("Calculated SE of model:",MSE_calculated)

par_LS.est<-LS_logL_nonlinear_full_constraint$par
OI<-solve(LS_logL_nonlinear_full_constraint$hessian)
par_LS.se<-sqrt(diag(OI))

Start_v_LS
par_LS.est

par_LS_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_gain_threshold","hgap_loss_slope","hgap_loss_threshold",
                   "correction_1","correction_2")
par_LS <- data.table(cbind(par_LS_name,par_LS.est,par_LS.se))
par_LS$tstat <- as.numeric(par_LS$par_LS.est)/as.numeric(par_LS$par_LS.se)

par_LS 
```
