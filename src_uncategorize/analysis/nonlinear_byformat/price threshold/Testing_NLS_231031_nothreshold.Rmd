---
title: "Estimating Non Linear Threshold for Selected Brands by Least Square Method"
output: html_notebook
---

We import Ramlosa at Supermarket datasets that has statistical evidence for "historical price gap"

```{r load relevant library}
library(dplyr) #for mutate factor
library(data.table) #turning results in table
```

```{r import dataset}
df_his <- read.csv("../../../../src/analysis/nonlinear_byformat/price threshold/ramlosa_super_histgap.csv")
df_his <- df_his %>% mutate(vecka=droplevels(as.factor(vecka))) 

df_full <- read.csv("../../../../src/analysis/nonlinear_byformat/price threshold/loka_super_fullgap.csv")
df_full <- df_full %>% mutate(vecka=droplevels(as.factor(vecka))) 
```

\section{Without Competitive Price}

Model Free Evidence Between Price and Sales
```{r plot price and sales for ramlosa, echo=TRUE}
plot(df_his$vecka, df_his$avgfinalprice, main = "Ramlosa Price in Supermarket", xlab = "Week", ylab = "Average final price", col="blue")

plot(df_his$totalvolume ~ df_his$avgfinalprice, main = "Ramlosa Price & Sales (Vol) in Supermarket", col="blue")
abline(lm(df_his$totalvolume ~ df_his$avgfinalprice), col="blue")

hist(df_his$dlogavgfinalprice)

summary(df_his$dlogavgfinalprice)
```

(1) Simple Model to calculate error (correction) term: $$ (1) ln(S_{i,t-1}) = a_{0i}+a_{1i}ln(P_{it-1}) + e_{it} $$ 

(0) Calculate Linear Model to get initial value for optimization
$$ \Delta ln(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta (P_{it})+ \phi_1[ln(S_{i,t-1})-\phi_2 ln(P_{i,t-1}))] $$

```{r linear model}
lm_his_linear <- lm(dlogtotalvolume ~ dlogavgfinalprice + log(totalvolume1) + log(avgfinalprice1) ,data=df_his)

summary(lm_his_linear)


c_his_lm <- summary(lm_his_linear)$coefficients[1,1]
alpha_0_his_lm <- summary(lm_his_linear)$coefficients[2,1]
phi_1_his_lm <- summary(lm_his_linear)$coefficients[3,1]
phi_2_his_lm <- (summary(lm_his_linear)$coefficients[4,1])/(summary(lm_his_linear)$coefficients[3,1]) # this coef = phi1*phi2

paste("Initial Value for constant term:", c_his_lm) 
paste("Initial Value for base elasticity:", alpha_0_his_lm) 
paste("Initial Value for phi1:", phi_1_his_lm) 
paste("Initial Value for phi2:", phi_2_his_lm) #should be positive?
```
Objective: We want to estimate nonlinear model with historical price gap:
$$\Delta ln(S_{i,t}) = c +\{\alpha_{0}
 + \frac{\alpha_{HG}}{1+exp(\gamma(HistPGap_{i,t}))-b_{HG})} +\frac{\alpha_{HL}}{1+exp(-\gamma(HistPGap_{i,t}))-b_{HL})}\}\Delta ln(P_{i,t})\\ 
+ \phi_1[ln(S_{i,t-1})+\phi_2 ln(P_{i,t-1}))]$$


We will obtain initial value of thresholds ($\beta_G,\beta_L$)  from distribution of $\Delta (P_{it}$ and change of slope by moderate change ($\alpha_G,\alpha_L$) and assume symmetrical case.

```{r assume alpha and beta}
alpha_g_his_lm <- -0.1
alpha_l_his_lm <- 0.1


paste("Initial Value for change slope gain (alphaG):", alpha_g_his_lm) 
paste("Initial Value for change slope loss (alphaL):", alpha_l_his_lm) 
paste("Initial Value for threshold gain (betaG):", beta_g_his_lm) 
paste("Initial Value for threshold loss (betaL):", beta_l_his_lm) #should be positive?
```


Then, we estimate using least square method (minimizing SSE)

```{r Estimate with NLS (Histgap)}

LS_nonlinear_his <- function(parvec){
  
  F_H_G <- 1/(1+exp(gamma*(df_his$hgap)))
  F_H_L <- 1/(1+exp(-gamma*(df_his$hgap)))
  

  ut <- df_his$dlogtotalvolume - (parvec[1] + (parvec[2] 
                                         + parvec[3]*F_H_G + parvec[4]*F_H_L)*df_his$dlogavgfinalprice 
                            + parvec[5]*((log(df_his$totalvolume1))+parvec[6]*log(df_his$avgfinalprice1)))
  parvec_7t <- sqrt(parvec[7]*parvec[7])
  logL <- sum (-0.5* log(parvec_7t) - 0.5*ut^2/parvec_7t)
  return(-logL)
}

  gamma <- 500 #assumed

  parvec_1 <- c_his_lm
  parvec_2 <- alpha_0_his_lm
  parvec_3 <- alpha_g_his_lm
  parvec_4 <- alpha_l_his_lm 
  parvec_5 <- phi_1_his_lm
  parvec_6 <- phi_2_his_lm
  parvec_7 <- 0.35
  

Start_v_LS <- c(parvec_1,parvec_2,parvec_3,parvec_4,parvec_5,parvec_6,parvec_7)

  n <- dim(df_his)[1]
  k <- length(Start_v_LS)


LS_logL_nonlinear_his_constraint = optim(Start_v_LS,
                  fn = LS_nonlinear_his, # function to maximize
                  method = "BFGS",
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  )

MSE_calculated <- LS_logL_nonlinear_his_constraint$value/(n-k)

paste("Calculated SE of model:",MSE_calculated)

par_LS.est<-LS_logL_nonlinear_his_constraint$par
OI<-solve(LS_logL_nonlinear_his_constraint$hessian)
par_LS.se<-sqrt(diag(OI))

Start_v_LS
par_LS.est

par_LS_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_loss_slope",
                   "correction_1","correction_2")
par_LS <- data.table(cbind(par_LS_name,par_LS.est,par_LS.se))
par_LS$tstat <- as.numeric(par_LS$par_LS.est)/as.numeric(par_LS$par_LS.se)

par_LS 
```

Plot
```{r plot result from LS}
c_0 <- par_LS.est[1]
alpha0 <- par_LS.est[2]
alpha_G <- par_LS.est[3]
alpha_L <- par_LS.est[4]
phi_1_his <- par_LS.est[5]
phi_2_his <- par_LS.est[6]

# Defining x-values
graph_reso <- 0.01
x_values <- seq(min(df_his$dlogavgfinalprice), max(df_his$dlogavgfinalprice), by = graph_reso)
xgap_values <- seq(min(df_his$hgap), max(df_his$hgap), by = graph_reso)


# Defining various functions to plot
NLPE <- function(dlogavgfinalprice,hgap)
      {( alpha0 + alpha_G*( 1 + exp(gamma*(hgap) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap) ) )^-1 )*dlogavgfinalprice}
TransF <- function(hgap){alpha0 + alpha_G*( 1 + exp(gamma*(hgap) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap)))^-1}

F_G <- function(x){( 1 + exp( gamma*(hgap) ) )^-1}
F_L <- function(x){( 1 + exp( -gamma*(hgap) ) )^-1}

NLPE_values <- NLPE(dlogavgfinalprice=x_values,hgap=xgap_values)
TransF_values <- TransF(hgap=xgap_values)
time <- seq(1:151)

#Plot
plot(x_values, NLPE_values, type = "l", main = "Nonlinear price elasticities Ramlosa", xlab = "dlogavgfinalprice", ylab = "NLPE")
plot(xgap_values, TransF_values, type = "l", main = "Smooth Transition Functions", xlab = "hispricegap", ylab = "STF")
```

```{r plot linear vs nonlinear}
linear_predict <- function(dlogavgfinalprice,totalvolume1,avgfinalprice1){
  c_his_lm + alpha_0_his_lm*dlogavgfinalprice + phi_1_his_lm*log(totalvolume1) + (phi_1_his_lm*phi_2_his_lm)*log(avgfinalprice1)
  }

nonlinear_predict <- function(dlogavgfinalprice,hgap,totalvolume1,avgfinalprice1)
{c_0 +(alpha0 + alpha_G*( 1 + exp(gamma*(hgap) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap) ) )^-1 )*dlogavgfinalprice + phi_1_his*(log(df_his$totalvolume1))+(phi_1_his*phi_2_his*log(df_his$avgfinalprice1))}

pre_linear <- cbind(linear_predict(dlogavgfinalprice=df_his$dlogavgfinalprice,totalvolume1 = df_his$totalvolume1,avgfinalprice1 = df_his$avgfinalprice1),df_his$dlogavgfinalprice,c("linear"))

pre_nonlinear<- cbind(nonlinear_predict(dlogavgfinalprice=df_his$dlogavgfinalprice,hgap=df_his$dlogavgfinalprice,totalvolume1 = df_his$totalvolume1,avgfinalprice1 = df_his$avgfinalprice1),df_his$dlogavgfinalprice,c("nonlinear"))

actual <- cbind(df_his$dlogtotalvolume,df_his$dlogavgfinalprice,c("actual"))

compare_actual_predict <- rbind(actual,pre_linear,pre_nonlinear)


plot(compare_actual_predict[,2], compare_actual_predict[,1], pch = 19,col = factor(compare_actual_predict[,3]),
     xlab="dlogPrice", ylab="dlogTotalVolume")
legend("topright",
       legend = levels(factor(compare_actual_predict[,3])),
       pch = 19,
       col = factor(levels(factor(compare_actual_predict[,3]))))
```
```{r check}
linear_predict <- function(dlogavgfinalprice){alpha_0_his_lm*dlogavgfinalprice}

nonlinear_predict <- function(dlogavgfinalprice,hgap)
{(alpha0 + alpha_G*( 1 + exp(gamma*(hgap-beta_G) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap-beta_L) ) )^-1 )*dlogavgfinalprice}

pre_linear <- cbind(linear_predict(dlogavgfinalprice=df_his$dlogavgfinalprice),df_his$dlogavgfinalprice,c("linear"))

pre_nonlinear<- cbind(nonlinear_predict(dlogavgfinalprice=df_his$dlogavgfinalprice,hgap=df_his$dlogavgfinalprice),df_his$dlogavgfinalprice,c("nonlinear"))


compare_actual_predict <- rbind(pre_linear,pre_nonlinear)


plot(compare_actual_predict[,2], compare_actual_predict[,1], pch = 19,col = factor(compare_actual_predict[,3]),
     xlab="dlogPrice", ylab="PriceEffect")
legend("topright",
       legend = levels(factor(compare_actual_predict[,3])),
       pch = 19,
       col = factor(levels(factor(compare_actual_predict[,3]))))

```



