---
title: "Estimating Non Linear Threshold for Selected Brands"
output: html_notebook
---

We import two datasets (Bottled Water Category) that has statistical evidence for "historical price gap" (Ramlosa at Supermarket) and "both historical and competitive price gap" (Loka at Supermarket)

```{r load relevant library}
library(dplyr) #for mutate factor
library(data.table) #turning results in table
```

```{r import dataset}
df_his <- read.csv("../../../../src/analysis/nonlinear_byformat/price threshold/ramlosa_super_histgap.csv")
df_his <- df_his %>% mutate(vecka=droplevels(as.factor(vecka))) 
df_full <- read.csv("../../../../src/analysis/nonlinear_byformat/price threshold/loka_super_fullgap.csv")
df_full <- df_full %>% mutate(vecka=droplevels(as.factor(vecka))) 
```

Model Free Evidence Between Price and Sales
```{r plot price and sales for ramlosa, echo=TRUE}
plot(df_his$vecka, df_his$avgfinalprice, main = "Ramlosa Price in Supermarket", xlab = "Week", ylab = "Average final price", col="blue")

plot(df_his$totalvolume ~ df_his$avgfinalprice, main = "Ramlosa Price & Sales (Vol) in Supermarket", col="blue")
abline(lm(df_his$totalvolume ~ df_his$avgfinalprice), col="blue")
```

```{r plot price and sales for loka}
plot(df_full$vecka, df_full$avgfinalprice, main = "Loka Price in Supermarket", xlab = "Week", ylab = "Average final price", col="blue")

plot(df_full$totalvolume ~ df_full$avgfinalprice, main = "Loka Price & Sales (Vol) in Supermarket", col="blue")
abline(lm(df_full$totalvolume ~ df_full$avgfinalprice), col="blue")
```

```{r generate Copula Term}
#According to Hannes Code
make_copula <- function(x) {
		if (length(unique(x))==1) return(as.numeric(rep(NA, length(x))))
		return(ifelse(ecdf(x)(x)==1, qnorm(1-.0000001), qnorm(ecdf(x)(x))))}
#This functions transforms a variable (condition: non-normally distributed) to its copula-correction term which can be entered in model estimation. See Park and Gupta (2012, Marketing Science)

df_his$cop_logfinalprice <- make_copula(log((df_his$avgfinalprice)))
df_his$cop_logfinalprice1 <- make_copula(log((df_his$avgfinalprice1)))
df_his$cop_logavgcompfinalprice <- make_copula(log(df_his$avgcompfinalprice))

df_full$cop_logfinalprice <- make_copula(log((df_full$avgfinalprice)))
df_full$cop_logfinalprice1 <- make_copula(log((df_full$avgfinalprice1)))
df_full$cop_logavgcompfinalprice <- make_copula(log(df_full$avgcompfinalprice))
```


(1) Simple Model to calculate error (correction) term: $$ (1) ln(S_{i,t-1}) = a_{0i}+a_{1i}ln(P_{it-1}) +a_{2i}Copulaln(P_{it-1}) + e_{it} $$ 
```{r generate error term for ECM}
lm_sim_his <- lm(log(totalvolume1) ~ log(avgfinalprice1) + cop_logfinalprice1, data = df_his) 
df_his$et_hat = residuals(lm_sim_his)

lm_sim_full <- lm(log(totalvolume1) ~ log(avgfinalprice1) + cop_logfinalprice1, data = df_full) 
df_full$et_hat = residuals(lm_sim_full)
```

(2) Ideally we want to estimate:
$$(2) \Delta ln(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta (P_{it})+\beta_{2i}\Delta ln(CompP_{it}) + \phi_1e_it +  ... $$
Where:

$\beta_{1i}$ for brand that has statistical evidence for "historical price gap" is $$F(GAP) = \alpha_{0i}+ \alpha_{GH}f(HistPGap_{i,t})_G+ \alpha_{GL}f(HistPGap_{i,t})_L$$ 


and 

$\beta_{1i}$ for brand that has statistical evidence for "both historical and competitive price gap" is $$F(GAP) = \alpha_{0i}+ \alpha_{HG}f(HistP_{i,t})_G+ \alpha_{HL}f(HistPGap_{i,t})_L + \alpha_{CG}f(CompPGap_{i,t})_G+ \alpha_{CL}f(CompPGap_{i,t})_L$$ 


To incorporate $F(GAP)$ in (2) and estimate the parameters, we need Maximum likelihood estimation

For simplicity, we will set initial value of each $\beta_ki$ based on the linear estimation (2) (i.e., $\alpha_{0i} = \beta_{1i}$)

Our challenging task is to set the initial value for $\alpha_{HG}$, $\alpha_{HL}$, $\alpha_{CG}$, $\alpha_{CL}$ which affect the curvature (slope or elasticity) of $\Delta P_{it}$ 

and further $b_{HG}$,$b_{HL}$,$b_{CG}$,$b_{CL}$ which are nested in $f(HistP_{i,t})_G$, $f(HistP_{i,t})_L$, $f(CompP_{i,t})_G$, $f(CompP_{i,t})_L$ (respectively) indicating the inflection points (or threshold)


We start with Ramlosa at Supermarket that has statistical evidence for "historical price gap"

Objective: We want to estimate nonlinear model with historical price gap:
$$\Delta ln(S_{i,t}) = c +\{\alpha_{0}
 + \frac{\alpha_{HG}}{1+exp(\gamma(HistPGap_{i,t}))-b_{HG})} +\frac{\alpha_{HL}}{1+exp(-\gamma(HistPGap_{i,t}))-b_{HL})}\}\Delta ln(P_{i,t})\\ 
+ \kappa_{1}\Delta ln(CompP_{i,t}) + \phi_1[ln(S_{i,t-1})+\phi_2 ln(P_{i,t-1}))] + \delta_1 CopulalnP + \delta_1 CopulalnCompP$$


```{r Run linear model for starting value (HistGap)}
#run linear regression, for simplicity, we will not add other marketing-related and time-related variables at this stage of documenting
lm_his_linear <- lm(dlogtotalvolume ~ dlogavgfinalprice + dlogavgcompfinalprice + et_hat + cop_logfinalprice + cop_logavgcompfinalprice ,data=df_his)

summary(lm_his_linear)

alpha_0_his <- summary(lm_his_linear)$coefficients[2,1]
c_his <- summary(lm_his_linear)$coefficients[1,1]
kappa_1_his <- summary(lm_his_linear)$coefficients[3,1]
phi_1_his <- summary(lm_his_linear)$coefficients[4,1]
delta_1_his <- summary(lm_his_linear)$coefficients[5,1]
delta_2_his <- summary(lm_his_linear)$coefficients[6,1]

```



```{r MLE Setting (HistGap)}
#Define loglikelihood function for nonlinear model with historical price gap
logL_nonlinear_his <- function(parvec){
  
  F_H_G <- 1/(1+exp(gamma*(df_his$hgap - parvec[4])))
  F_H_L <- 1/(1+exp(-gamma*(df_his$hgap - parvec[6])))
  
  
  ut <- df_his$dlogtotalvolume - (parvec[1] + (parvec[2] 
                                         + parvec[3]*F_H_G + parvec[5]*F_H_L)*df_his$dlogavgfinalprice 
                            + parvec[7]*df_his$dlogavgcompfinalprice          
                            + parvec[8]*df_his$et_hat
                            + parvec[9]*df_his$cop_logfinalprice + parvec[10]*df_his$cop_logavgcompfinalprice)
  logL <- sum (-0.5* log(parvec[11]) - 0.5*ut^2/parvec[11] )
  return(-logL)
}
  gamma <- 100 #assumed

  parvec_1 <- c_his
  parvec_2 <- alpha_0_his
  parvec_3 <- 0.25 #Guessing number from SE of price elasticity
  parvec_4 <- 0.17 #Guessing number from SD of historical price gap
  parvec_5 <- 0.25 #Guessing number from SE of price elasticity
  parvec_6 <-  -0.17 #Guessing number from SD of historical price gap (negative because it's loss)
  parvec_7 <- kappa_1_his
  parvec_8 <- phi_1_his
  parvec_9 <- delta_1_his
  parvec_10 <- delta_2_his
  parvec_11 <- 1 #se from model
  Start_v <- c(parvec_1,parvec_2,parvec_3,parvec_4,parvec_5,parvec_6,parvec_7,parvec_8,
               parvec_9,parvec_10,parvec_11)
```

```{r Estimate MLE (Histgap)}
MLE_logL_nonlinear_his = optim(Start_v,
                  fn = logL_nonlinear_his, # function to maximize
                  method = "BFGS",
                  #method = "SANN",
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  
)

par.est<-MLE_logL_nonlinear_his$par
#par.est
# Calculating the Hessian. Needed to compute std. for estimates
OI<-solve(MLE_logL_nonlinear_his$hessian)
par.se<-sqrt(diag(OI))

par_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_gain_threshold","hgap_loss_slope","hgap_loss_threshold",
                   "compprice","ethat","cop_price","cop_compprice","model_SE")
par <- data.table(cbind(par_name,par.est,par.se))
par$tstat <- as.numeric(par$par.est)/as.numeric(par$par.se)

par
```
```{r Estimate with NLS (Histgap)}

LS_nonlinear_his <- function(parvec){
  
  F_H_G <- 1/(1+exp(gamma*(df_his$hgap - parvec[4])))
  F_H_L <- 1/(1+exp(-gamma*(df_his$hgap - parvec[6])))
  

  ut <- df_his$dlogtotalvolume - (parvec[1] + (parvec[2] 
                                         + parvec[3]*F_H_G + parvec[5]*F_H_L)*df_his$dlogavgfinalprice 
                            + parvec[7]*df_his$dlogavgcompfinalprice          
                            + parvec[8]*df_his$et_hat
                            + parvec[9]*df_his$cop_logfinalprice + parvec[10]*df_his$cop_logavgcompfinalprice)
  SSE <- sum(ut^2)
  return(SSE)
}

  Start_v_LS <- c(parvec_1,parvec_2,parvec_3,parvec_4,parvec_5,parvec_6,parvec_7,parvec_8,
               parvec_9,parvec_10)


LS_logL_nonlinear_his_constraint = optim(Start_v_LS,
                  fn = LS_nonlinear_his, # function to maximize
                  method = "BFGS",
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  )

MSE_calculated <- LS_logL_nonlinear_his_constraint$value/152 #152 is n

par_constraint.est<-LS_logL_nonlinear_his_constraint$par
#par.est
# Calculating the Hessian. Needed to compute std. for estimates
OI_constraint<-solve(MLE_logL_nonlinear_his_constraint$hessian)
par_constraint.se<-sqrt(diag(OI_constraint))

par_constraint_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_gain_threshold","hgap_loss_slope","hgap_loss_threshold",
                   "compprice","ethat","cop_price","cop_compprice","model_SE")
par_constraint <- data.table(cbind(par_constraint_name,par_constraint.est,par_constraint.se))

par_constraint
```


```{r Estimate MLE WITH CONSTRAINT (Histgap) test 1}
lower_v <- c(-99,-99,-99,-99,-99,-99,-99,-99,-99,-99,0.0001)

MLE_logL_nonlinear_his_constraint = optim(Start_v,
                  fn = logL_nonlinear_his, # function to maximize
                  method = "L-BFGS-B",
                  lower = lower_v,
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  ) 

par_constraint.est<-MLE_logL_nonlinear_his_constraint$par
#par.est
# Calculating the Hessian. Needed to compute std. for estimates
OI_constraint<-solve(MLE_logL_nonlinear_his_constraint$hessian)
par_constraint.se<-sqrt(diag(OI_constraint))

par_constraint_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_gain_threshold","hgap_loss_slope","hgap_loss_threshold",
                   "compprice","ethat","cop_price","cop_compprice","model_SE")
par_constraint <- data.table(cbind(par_constraint_name,par_constraint.est,par_constraint.se))

par_constraint
```
```{r Estimate MLE WITH CONSTRAINT (Histgap) test 2}
lower_v <- c(-99,-99,-99,-99,-99,-99,-99,-99,-99,-99,0.001)

MLE_logL_nonlinear_his_constraint = optim(Start_v,
                  fn = logL_nonlinear_his, # function to maximize
                  method = "L-BFGS-B",
                  lower = lower_v,
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  ) 

par_constraint.est<-MLE_logL_nonlinear_his_constraint$par
#par.est
# Calculating the Hessian. Needed to compute std. for estimates
OI_constraint<-solve(MLE_logL_nonlinear_his_constraint$hessian)
par_constraint.se<-sqrt(diag(OI_constraint))

par_constraint_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_gain_threshold","hgap_loss_slope","hgap_loss_threshold",
                   "compprice","ethat","cop_price","cop_compprice","model_SE")
par_constraint <- data.table(cbind(par_constraint_name,par_constraint.est,par_constraint.se))

par_constraint
```

```{r Estimate MLE WITH CONSTRAINT (Histgap) test 3}
lower_v <- c(-99,-99,-99,-99,-99,-99,-99,-99,-99,-99,0.01)

MLE_logL_nonlinear_his_constraint = optim(Start_v,
                  fn = logL_nonlinear_his, # function to maximize
                  method = "L-BFGS-B",
                  lower = lower_v,
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  ) 

par_constraint.est<-MLE_logL_nonlinear_his_constraint$par
#par.est
# Calculating the Hessian. Needed to compute std. for estimates
OI_constraint<-solve(MLE_logL_nonlinear_his_constraint$hessian)
par_constraint.se<-sqrt(diag(OI_constraint))

par_constraint_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_gain_threshold","hgap_loss_slope","hgap_loss_threshold",
                   "compprice","ethat","cop_price","cop_compprice","model_SE")
par_constraint <- data.table(cbind(par_constraint_name,par_constraint.est,par_constraint.se))

par_constraint
```

```{r Estimate MLE WITH CONSTRAINT (Histgap) test 4}
lower_v <- c(-99,-99,-99,-99,-99,-99,-99,-99,-99,-99,0.10)

MLE_logL_nonlinear_his_constraint = optim(Start_v,
                  fn = logL_nonlinear_his, # function to maximize
                  method = "L-BFGS-B",
                  lower = lower_v,
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  ) 

par_constraint.est<-MLE_logL_nonlinear_his_constraint$par
#par.est
# Calculating the Hessian. Needed to compute std. for estimates
OI_constraint<-solve(MLE_logL_nonlinear_his_constraint$hessian)
par_constraint.se<-sqrt(diag(OI_constraint))

par_constraint_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_gain_threshold","hgap_loss_slope","hgap_loss_threshold",
                   "compprice","ethat","cop_price","cop_compprice","model_SE")
par_constraint <- data.table(cbind(par_constraint_name,par_constraint.est,par_constraint.se))

par_constraint
```

```{r Illustrating from MLE (Histgap)}
alpha0 <- par.est[2]
alpha_G <- par.est[3]
beta_G <- par.est[4]
alpha_L <- par.est[5]
beta_L <- par.est[6]

# Defining x-values
graph_reso <- 0.01
x_values <- seq(min(df_his$dlogavgfinalprice), max(df_his$dlogavgfinalprice), by = graph_reso)
xgap_values <- seq(min(df_his$hgap), max(df_his$hgap), by = graph_reso)


# Defining various functions to plot
NLPE <- function(dlogavgfinalprice,hgap)
      {( alpha0 + alpha_G*( 1 + exp(gamma*(hgap-beta_G) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap-beta_L) ) )^-1 )*dlogavgfinalprice}
TransF <- function(hgap){alpha0 + alpha_G*( 1 + exp(gamma*(hgap-beta_G) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap-beta_L)))^-1}

F_G <- function(x){( 1 + exp( gamma*(hgap-beta_G) ) )^-1}
F_L <- function(x){( 1 + exp( -gamma*(hgap-beta_L) ) )^-1}

NLPE_values <- NLPE(dlogavgfinalprice=x_values,hgap=xgap_values)
TransF_values <- TransF(hgap=xgap_values)
time <- seq(1:151)

#Plot
plot(x_values, NLPE_values, type = "l", main = "Nonlinear price elasticities Ramlosa", xlab = "dlogavgfinalprice", ylab = "NLPE")
plot(xgap_values, TransF_values, type = "l", main = "Smooth Transition Functions", xlab = "hispricegap", ylab = "STF")
```

Next, We move to Loka at Supermarket that has statistical evidence for "both historical and competitive price gap"

Objective: We want to estimate nonlinear model with historical price gap:
$$\Delta ln(S_{i,t}) = c +\{\alpha_{0}
 + \frac{\alpha_{HG}}{1+exp(\gamma(HistPGap_{i,t}))-b_{HG})} +\frac{\alpha_{HL}}{1+exp(-\gamma(HistPGap_{i,t}))-b_{HL})}\\
 + \frac{\alpha_{HG}}{1+exp(\gamma(CompPGap_{i,t}))-b_{CG})} +\frac{\alpha_{CL}}{1+exp(-\gamma(CompPGap_{i,t}))-b_{CL})}\}\Delta ln(P_{i,t})\\ 
+ \kappa_{1}\Delta ln(CompP_{i,t}) + \phi_1[ln(S_{i,t-1})+\phi_2 ln(P_{i,t-1}))] + \delta_1 CopulalnP + \delta_1 CopulalnCompP$$

```{r Run linear model for starting value (CompandHistGap)}
lm_full_linear <- lm(dlogtotalvolume ~ dlogavgfinalprice + dlogavgcompfinalprice + et_hat + cop_logfinalprice + cop_logavgcompfinalprice ,data=df_full)

summary(lm_full_linear)

alpha_0_full <- summary(lm_full_linear)$coefficients[2,1]
c_full <- summary(lm_full_linear)$coefficients[1,1]
kappa_1_full <- summary(lm_full_linear)$coefficients[3,1]
phi_1_full <- summary(lm_full_linear)$coefficients[4,1]
delta_1_full <- summary(lm_full_linear)$coefficients[5,1]
delta_2_full <- summary(lm_full_linear)$coefficients[6,1]
```
```{r MLE Setting (CompandHistGap)}
#Define loglikelihood function for nonlinear model with historical price gap
logL_nonlinear_full <- function(parvec){
  
  F_H_G <- 1/(1+exp(gamma*(df_full$hgap - parvec[4])))
  F_H_L <- 1/(1+exp(-gamma*(df_full$hgap - parvec[6])))
  
  F_C_G <- 1/(1+exp(gamma*(df_full$cgap - parvec[8])))
  F_C_L <- 1/(1+exp(-gamma*(df_full$cgap - parvec[10])))
  
  
  ut <- df_full$dlogtotalvolume - (parvec[1] + (parvec[2] 
                                         + parvec[3]*F_H_G + parvec[5]*F_H_L
                                         + parvec[7]*F_C_G + parvec[9]*F_C_L)*df_full$dlogavgfinalprice 
                            + parvec[11]*df_full$dlogavgcompfinalprice          
                            + parvec[12]*df_full$et_hat
                            + parvec[13]*df_full$cop_logfinalprice + parvec[14]*df_full$cop_logavgcompfinalprice)
  logL <- sum (-0.5* log(parvec[15]) - 0.5*ut^2/parvec[15] )
  return(-logL)
}
  gamma <- 100 #assumed

  parvec_1 <- c_full
  parvec_2 <- alpha_0_full
  parvec_3 <- 0.12 #Guessing number from SE of price elasticity
  parvec_4 <- 0.24 #Guessing number from SD of historical price gap
  parvec_5 <- 0.12 #Guessing number from SE of price elasticity
  parvec_6 <-  -0.24 #Guessing number from SD of historical price gap (negative because it's loss)
  parvec_7 <-  0.12 #Guessing number from SE of price elasticity
  parvec_8 <-  0.34 #Guessing number from SD of competitive price gap
  parvec_9 <-  0.12 #Guessing number from SE of price elasticity
  parvec_10 <-  -0.34 #Guessing number from SD of competitive price gap (negative because it's loss)
  parvec_11 <- kappa_1_full
  parvec_12 <- phi_1_full
  parvec_13 <- delta_1_full
  parvec_14 <- delta_2_full
  parvec_15 <- 0.1 #se residuals from linear model
  Start_v <- c(parvec_1,parvec_2,parvec_3,parvec_4,parvec_5,parvec_6,parvec_7,parvec_8,
               parvec_9,parvec_10,parvec_11,parvec_12,parvec_13,parvec_14,parvec_15)
```

```{r Estimate MLE (CompandHistgap)}
MLE_logL_nonlinear_full = optim(Start_v,
                  fn = logL_nonlinear_full, # function to maximize
                  method = "BFGS",
                  #method = "SANN",
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  
)

par_full.est<-MLE_logL_nonlinear_full$par
#par.est
# Calculating the Hessian. Needed to compute std. for estimates
OI_full<-solve(MLE_logL_nonlinear_full$hessian)
par_full.se<-sqrt(diag(OI_full))

par_full_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_gain_threshold","hgap_loss_slope","hgap_loss_threshold",
                   "cgap_gain_slope","cgap_gain_threshold","cgap_loss_slope","cgap_loss_threshold",
                   "compprice","ethat","cop_price","cop_compprice","model_SE")
par_full <- data.table(cbind(par_full_name,par_full.est,par_full.se))
par_full$tstat <- as.numeric(par_full$par_full.est)/as.numeric(par_full$par_full.se)

par_full
```

```{r Illustrating from MLE (CompandHistgap)}
alpha0 <- par_full.est[2]
alpha_HG <- par_full.est[3]
beta_HG <- par_full.est[4]
alpha_HL <- par_full.est[5]
beta_HL <- par_full.est[6]
alpha_CG <- par_full.est[7]
beta_CG <- par_full.est[8]
alpha_CL <- par_full.est[9]
beta_CL <- par_full.est[10]

# Defining x-values
graph_points <- 200
x_values <- seq(min(df_full$dlogavgfinalprice), max(df_full$dlogavgfinalprice), length.out=graph_points)
xhgap_values <- seq(min(df_full$hgap), max(df_full$hgap), length.out=graph_points)
xcgap_values <- seq(min(df_full$cgap), max(df_full$cgap), length.out=graph_points)


# Defining various functions to plot
NLPE_full <- function(dlogavgfinalprice,hgap,cgap)
{( alpha0 + alpha_HG*( 1 + exp( gamma*(hgap-beta_HG) ) )^-1 + alpha_HL*( 1 + exp(-gamma*(hgap-beta_HL) ) )^-1 
         + alpha_CG*( 1 + exp( gamma*(cgap-beta_CG) ) )^-1 + alpha_CL*( 1 + exp(-gamma*(cgap-beta_CL) ) )^-1)*dlogavgfinalprice}
TransF_H <- function(hgap){alpha0 + alpha_HG*( 1 + exp( gamma*(hgap-beta_HG) ) )^-1 + alpha_HL*(1+exp(-gamma*(hgap-beta_HL) ))^-1}
TransF_C <- function(cgap){alpha0 + alpha_CG*(1 + exp( gamma*(cgap-beta_CG)))^-1 + alpha_CL*( 1+exp(-gamma*(cgap-beta_CL)))^-1}

F_HG <- function(x){( 1 + exp( gamma*(hgap-beta_G) ) )^-1}
F_HL <- function(x){( 1 + exp( -gamma*(hgap-beta_L) ) )^-1}
F_CG <- function(x){( 1 + exp( gamma*(cgap-beta_G) ) )^-1}
F_CL <- function(x){( 1 + exp( -gamma*(cgap-beta_L) ) )^-1}

NLPE_full_values <- NLPE_full(dlogavgfinalprice=x_values,hgap=xhgap_values,cgap=xcgap_values)
TransF_values_H <- TransF_H(hgap=xhgap_values)
TransF_values_C <- TransF_C(cgap=xcgap_values)
time <- seq(1:151)

#Plot
plot(x_values, NLPE_full_values, type = "l", main = "Nonlinear price elasticities Loka", xlab = "dlogavgfinalprice", ylab = "NLPE")
plot(xhgap_values, TransF_values_H, type = "l", main = "Smooth Transition Functions (for Historical Price Gap)", xlab = "hispricegap", ylab = "STF")
plot(xcgap_values, TransF_values_C, type = "l", main = "Smooth Transition Functions (for Competitive Price Gap)", xlab = "comppricegap", ylab = "STF")

```
