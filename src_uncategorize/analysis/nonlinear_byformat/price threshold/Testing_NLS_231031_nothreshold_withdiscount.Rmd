---
title: "Estimating Non Linear Threshold for Selected Brands by Least Square Method"
output: html_notebook
---

We import Ramlosa at Supermarket datasets that has statistical evidence for "historical price gap"

```{r load relevant library}
library(dplyr) #for mutate factor
library(data.table) #turning results in table
```

```{r import dataset}
df_his <- read.csv("../../../../src/analysis/nonlinear_byformat/price threshold/ramlosa_super_histgap.csv")
df_his <- df_his %>% mutate(vecka=droplevels(as.factor(vecka))) 

df_full <- read.csv("../../../../src/analysis/nonlinear_byformat/price threshold/loka_super_fullgap.csv")
df_full <- df_full %>% mutate(vecka=droplevels(as.factor(vecka))) 
```

\section{Without Competitive Price}

Model Free Evidence Between Price and Sales
```{r plot price and sales for ramlosa, echo=TRUE}
plot(df_his$vecka, df_his$avgfinalprice, main = "Ramlosa Price in Supermarket", xlab = "Week", ylab = "Average final price", col="blue")

plot(df_his$totalvolume ~ df_his$avgfinalprice, main = "Ramlosa Price & Sales (Vol) in Supermarket", col="blue")
abline(lm(df_his$totalvolume ~ df_his$avgfinalprice), col="blue")

hist(df_his$dlogavgfinalprice)

summary(df_his$dlogavgfinalprice)
```

(1) Simple Model to calculate error (correction) term: $$ (1) ln(S_{i,t-1}) = a_{0i}+a_{1i}ln(P_{it-1}) + e_{it} $$ 

(0) Calculate Linear Model to get initial value for optimization
$$ \Delta ln(S_{i,t}) = \beta_{0i}+\beta_{1i}\Delta (P_{it})+ \phi_1[ln(S_{i,t-1})-\phi_2 ln(P_{i,t-1}))] $$

```{r linear model}
lm_his_linear <- lm(dlogtotalvolume ~ dlogavgfinalprice + log(totalvolume1) + log(avgfinalprice1) ,data=df_his)

summary(lm_his_linear)


c_his_lm <- summary(lm_his_linear)$coefficients[1,1]
alpha_0_his_lm <- summary(lm_his_linear)$coefficients[2,1]
phi_1_his_lm <- summary(lm_his_linear)$coefficients[3,1]
phi_2_his_lm <- (summary(lm_his_linear)$coefficients[4,1])/(summary(lm_his_linear)$coefficients[3,1]) # this coef = phi1*phi2

paste("Initial Value for constant term:", c_his_lm) 
paste("Initial Value for base elasticity:", alpha_0_his_lm) 
paste("Initial Value for phi1:", phi_1_his_lm) 
paste("Initial Value for phi2:", phi_2_his_lm) #should be positive?
```
Objective: We want to estimate nonlinear model with historical price gap:
$$\Delta ln(S_{i,t}) = c +\{\alpha_{0}
 + \frac{\alpha_{HG}}{1+exp(\gamma(HistPGap_{i,t}))-b_{HG})} +\frac{\alpha_{HL}}{1+exp(-\gamma(HistPGap_{i,t}))-b_{HL})}\}\Delta ln(P_{i,t})\\ 
+ \phi_1[ln(S_{i,t-1})+\phi_2 ln(P_{i,t-1}))]$$


We will obtain initial value of thresholds ($\beta_G,\beta_L$)  from distribution of $\Delta (P_{it}$ and change of slope by moderate change ($\alpha_G,\alpha_L$) and assume symmetrical case.

```{r assume alpha and beta}
alpha_g_his_lm <- 0
alpha_l_his_lm <- 0


paste("Initial Value for change slope gain (alphaG):", alpha_g_his_lm) 
paste("Initial Value for change slope loss (alphaL):", alpha_l_his_lm) 
```


Then, we estimate using least square method (minimizing SSE)

```{r Estimate with NLS (Histgap)}

LS_nonlinear_his <- function(parvec){
  
  F_H_G <- 1/(1+exp(gamma*(df_his$hgap)))
  F_H_L <- 1/(1+exp(-gamma*(df_his$hgap)))
  

  ut <- df_his$dlogtotalvolume - (parvec[1] + (parvec[2] 
                                         + parvec[3]*F_H_G + parvec[4]*F_H_L)*df_his$dlogavgfinalprice 
                            + parvec[5]*((log(df_his$totalvolume1))+parvec[6]*log(df_his$avgfinalprice1)))
  parvec_7t <- sqrt(parvec[7]*parvec[7])
  logL <- sum (-0.5* log(parvec_7t) - 0.5*ut^2/parvec_7t)
  return(-logL)
}

  gamma <- 500 #assumed

  parvec_1 <- c_his_lm
  parvec_2 <- alpha_0_his_lm
  parvec_3 <- alpha_g_his_lm
  parvec_4 <- alpha_l_his_lm 
  parvec_5 <- phi_1_his_lm
  parvec_6 <- phi_2_his_lm
  parvec_7 <- 0.35
  

Start_v_LS <- c(parvec_1,parvec_2,parvec_3,parvec_4,parvec_5,parvec_6,parvec_7)

  n <- dim(df_his)[1]
  k <- length(Start_v_LS)


LS_logL_nonlinear_his_constraint = optim(Start_v_LS,
                  fn = LS_nonlinear_his, # function to maximize
                  method = "BFGS",
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  )

MSE_calculated <- LS_logL_nonlinear_his_constraint$value/(n-k)

paste("Calculated SE of model:",MSE_calculated)

par_LS.est<-LS_logL_nonlinear_his_constraint$par
OI<-solve(LS_logL_nonlinear_his_constraint$hessian)
par_LS.se<-sqrt(diag(OI))

Start_v_LS
par_LS.est

par_LS_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_loss_slope",
                   "correction_1","correction_2")
par_LS <- data.table(cbind(par_LS_name,par_LS.est,par_LS.se))
par_LS$tstat <- as.numeric(par_LS$par_LS.est)/as.numeric(par_LS$par_LS.se)

par_LS 
```
```{r try with constraint}
lower_v <- c(-Inf,-Inf,-Inf,-Inf,-Inf,-Inf,0.00001)

LS_nonlinear_his <- function(parvec){
  
  F_H_G <- 1/(1+exp(gamma*(df_his$hgap)))
  F_H_L <- 1/(1+exp(-gamma*(df_his$hgap)))
  

  ut <- df_his$dlogtotalvolume - (parvec[1] + (parvec[2] 
                                         + parvec[3]*F_H_G + parvec[4]*F_H_L)*df_his$dlogavgfinalprice 
                            + parvec[5]*((log(df_his$totalvolume1))+parvec[6]*log(df_his$avgfinalprice1)))
  parvec_7t <- sqrt(parvec[7]*parvec[7])
  logL <- sum (-0.5* log(parvec_7t) - 0.5*ut^2/parvec_7t)
  return(-logL)
}

  gamma <- 500 #assumed

  parvec_1 <- c_his_lm
  parvec_2 <- alpha_0_his_lm
  parvec_3 <- alpha_g_his_lm
  parvec_4 <- alpha_l_his_lm 
  parvec_5 <- phi_1_his_lm
  parvec_6 <- phi_2_his_lm
  parvec_7 <- 0.35
  

Start_v_LS <- c(parvec_1,parvec_2,parvec_3,parvec_4,parvec_5,parvec_6,parvec_7)

  n <- dim(df_his)[1]
  k <- length(Start_v_LS)


LS_logL_nonlinear_his_constraint = optim(Start_v_LS,
                  fn = LS_nonlinear_his, # function to maximize
                  method = "BFGS",
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  )

MSE_calculated <- LS_logL_nonlinear_his_constraint$value/(n-k)

paste("Calculated SE of model:",MSE_calculated)

par_LS.est<-LS_logL_nonlinear_his_constraint$par
OI<-solve(LS_logL_nonlinear_his_constraint$hessian)
par_LS.se<-sqrt(diag(OI))

Start_v_LS
par_LS.est

par_LS_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_loss_slope",
                   "correction_1","correction_2")
par_LS <- data.table(cbind(par_LS_name,par_LS.est,par_LS.se))
par_LS$tstat <- as.numeric(par_LS$par_LS.est)/as.numeric(par_LS$par_LS.se)

par_LS 

```



Plot
```{r plot result from LS}
c_0 <- par_LS.est[1]
alpha0 <- par_LS.est[2]
alpha_G <- par_LS.est[3]
alpha_L <- par_LS.est[4]
phi_1_his <- par_LS.est[5]
phi_2_his <- par_LS.est[6]

# Defining x-values
graph_reso <- 0.01
x_values <- seq(min(df_his$dlogavgfinalprice), max(df_his$dlogavgfinalprice), by = graph_reso)
xgap_values <- seq(min(df_his$hgap), max(df_his$hgap), by = graph_reso)


# Defining various functions to plot
NLPE <- function(dlogavgfinalprice,hgap)
      {( alpha0 + alpha_G*( 1 + exp(gamma*(hgap) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap) ) )^-1 )*dlogavgfinalprice}
TransF <- function(hgap){alpha0 + alpha_G*( 1 + exp(gamma*(hgap) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap)))^-1}

F_G <- function(x){( 1 + exp( gamma*(hgap) ) )^-1}
F_L <- function(x){( 1 + exp( -gamma*(hgap) ) )^-1}

NLPE_values <- NLPE(dlogavgfinalprice=x_values,hgap=xgap_values)
TransF_values <- TransF(hgap=xgap_values)
time <- seq(1:151)

#Plot
plot(x_values, NLPE_values, type = "l", main = "Nonlinear price elasticities Ramlosa", xlab = "dlogavgfinalprice", ylab = "NLPE")
plot(xgap_values, TransF_values, type = "l", main = "Smooth Transition Functions", xlab = "hispricegap", ylab = "STF")
```

```{r plot linear vs nonlinear}
linear_predict <- function(dlogavgfinalprice,totalvolume1,avgfinalprice1){
  c_his_lm + alpha_0_his_lm*dlogavgfinalprice + phi_1_his_lm*log(totalvolume1) + (phi_1_his_lm*phi_2_his_lm)*log(avgfinalprice1)
  }

nonlinear_predict <- function(dlogavgfinalprice,hgap,totalvolume1,avgfinalprice1)
{c_0 +(alpha0 + alpha_G*( 1 + exp(gamma*(hgap) ) )^-1 + alpha_L*( 1 + exp(-gamma*(hgap) ) )^-1 )*dlogavgfinalprice + phi_1_his*(log(df_his$totalvolume1))+(phi_1_his*phi_2_his*log(df_his$avgfinalprice1))}

pre_linear <- cbind(linear_predict(dlogavgfinalprice=df_his$dlogavgfinalprice,totalvolume1 = df_his$totalvolume1,avgfinalprice1 = df_his$avgfinalprice1),df_his$dlogavgfinalprice,c("linear"))

pre_nonlinear<- cbind(nonlinear_predict(dlogavgfinalprice=df_his$dlogavgfinalprice,hgap=df_his$dlogavgfinalprice,totalvolume1 = df_his$totalvolume1,avgfinalprice1 = df_his$avgfinalprice1),df_his$dlogavgfinalprice,c("nonlinear"))

actual <- cbind(df_his$dlogtotalvolume,df_his$dlogavgfinalprice,c("actual"))

compare_actual_predict <- rbind(actual,pre_linear,pre_nonlinear)


plot(compare_actual_predict[,2], compare_actual_predict[,1], pch = 19,col = factor(compare_actual_predict[,3]),
     xlab="dlogPrice", ylab="dlogTotalVolume")
legend("topright",
       legend = levels(factor(compare_actual_predict[,3])),
       pch = 19,
       col = factor(levels(factor(compare_actual_predict[,3]))))
```


```{r Estimate with NLS (HistgapandDis)}

LS_nonlinear_hisdisc <- function(parvec){
  
  F_H_G <- 1/(1+exp(gamma*(df_his$dlogavgpricebefore)))
  F_H_L <- 1/(1+exp(-gamma*(df_his$dlogavgpricebefore)))
  F_D_G <- 1/(1+exp(gamma*(df_his$dlognondepth)))
  F_D_L <- 1/(1+exp(-gamma*(df_his$dlognondepth)))
  

  ut <- df_his$dlogtotalvolume - (parvec[1] + (parvec[2]+ parvec[3]*F_H_G + parvec[4]*F_H_L)*df_his$dlogavgpricebefore
                                  + (parvec[5] + parvec[6]*F_D_G + parvec[7]*F_D_L)*df_his$dlognondepth
                            + parvec[8]*((log(df_his$totalvolume1))+parvec[9]*log(df_his$avgfinalprice1)))
  
  parvec_10t <- sqrt(parvec[10]*parvec[10])
  logL <- sum (-0.5* log(parvec_10t) - 0.5*ut^2/parvec_10t)
  return(-logL)
}

  gamma <- 500 #assumed
  
  
lm_full_linear <- lm(dlogtotalvolume ~ dlogavgpricebefore + dlognondepth + log(totalvolume1) + log(avgfinalprice1) ,data=df_his)

summary(lm_full_linear)


c_full_lm <- summary(lm_full_linear)$coefficients[1,1]
alpha_0_full_lm <- summary(lm_full_linear)$coefficients[2,1]
alpha_0_disc_lm <- summary(lm_full_linear)$coefficients[3,1]
phi_1_full_lm <- summary(lm_full_linear)$coefficients[4,1]
phi_2_full_lm <- (summary(lm_full_linear)$coefficients[5,1])/(summary(lm_full_linear)$coefficients[4,1]) # tfull coef = phi1*phi2
alpha_g_his_full_lm <- 0
alpha_l_his_full_lm <- 0
alpha_g_disc_full_lm <- 0
alpha_l_disc_full_lm <- 0


  
  parvec_1 <- c_full_lm
  parvec_2 <- alpha_0_full_lm
  parvec_3 <- alpha_g_his_full_lm
  parvec_4 <- alpha_l_his_full_lm
  parvec_5 <-  alpha_0_disc_lm
  parvec_6 <- alpha_g_disc_full_lm
  parvec_7 <- alpha_l_disc_full_lm 
  parvec_8 <- phi_1_full_lm
  parvec_9 <- phi_2_full_lm
  parvec_10 <- 0.5
  

Start_v_LS <- c(parvec_1,parvec_2,parvec_3,parvec_4,parvec_5,parvec_6,parvec_7,parvec_8,parvec_9,parvec_10)

  n <- dim(df_his)[1]
  k <- length(Start_v_LS)


LS_logL_nonlinear_his_constraint = optim(Start_v_LS,
                  fn = LS_nonlinear_hisdisc, # function to maximize
                  method = "BFGS",
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  )

MSE_calculated <- LS_logL_nonlinear_his_constraint$value/(n-k)

paste("Calculated SE of model:",MSE_calculated)

par_LS.est<-LS_logL_nonlinear_his_constraint$par
OI<-solve(LS_logL_nonlinear_his_constraint$hessian)
par_LS.se<-sqrt(diag(OI))

Start_v_LS
par_LS.est

par_LS_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_loss_slope","dgap_gain_slope","dgap_loss_slope",
                   "correction_1","correction_2")
par_LS <- data.table(cbind(par_LS_name,par_LS.est,par_LS.se))
par_LS$tstat <- as.numeric(par_LS$par_LS.est)/as.numeric(par_LS$par_LS.se)

par_LS 
```
```{r plot reg price results from LS}
c_0 <- par_LS.est[1]
alpha0_H <- par_LS.est[2]
alpha_H_G <- par_LS.est[3]
alpha_H_L <- par_LS.est[4]
alpha0_D <- par_LS.est[5]
alpha_D_G <- par_LS.est[6]
alpha_D_L <- par_LS.est[7]
phi_1_his <- par_LS.est[8]
phi_2_his <- par_LS.est[9]

# Defining x-values
graph_reso <- 0.01
x_values <- seq(min(df_his$dlogavgpricebefore), max(df_his$dlogavgpricebefore), by = graph_reso)
xgap_values <- seq(min(df_his$dlogavgpricebefore), max(df_his$dlogavgpricebefore), by = graph_reso)


# Defining various functions to plot
NLPE_H <- function(dlogavgpricebefore)
      {( alpha0_H + alpha_H_G*( 1 + exp(gamma*(dlogavgpricebefore) ) )^-1 + alpha_H_L*( 1 + exp(-gamma*(dlogavgpricebefore) ) )^-1 )*dlogavgpricebefore}
TransF_H <- function(dlogavgpricebefore){alpha0_H + alpha_H_G*( 1 + exp(gamma*(dlogavgpricebefore) ) )^-1 + alpha_H_L*( 1 + exp(-gamma*(dlogavgpricebefore)))^-1}

F_H_G <- function(x){( 1 + exp( gamma*(dlogavgpricebefore) ) )^-1}
F_H_L <- function(x){( 1 + exp( -gamma*(dlogavgpricebefore) ) )^-1}

NLPE_values_H <- NLPE_H(dlogavgpricebefore=xgap_values)
TransF_values_H <- TransF_H(dlogavgpricebefore=xgap_values)
time <- seq(1:151)

#Plot
plot(x_values, NLPE_values_H, type = "l", main = "Nonlinear REGULAR price elasticities Ramlosa", xlab = "dlogavgpricebefore", ylab = "NLPE")
plot(xgap_values, TransF_values_H, type = "l", main = "Smooth Transition Functions", xlab = "hisregpricegap", ylab = "STF")
```
```{r plot discount results from LS}
c_0 <- par_LS.est[1]
alpha0_H <- par_LS.est[2]
alpha_H_G <- par_LS.est[3]
alpha_H_L <- par_LS.est[4]
alpha0_D <- par_LS.est[5]
alpha_D_G <- par_LS.est[6]
alpha_D_L <- par_LS.est[7]
phi_1_his <- par_LS.est[8]
phi_2_his <- par_LS.est[9]

# Defining x-values
graph_reso <- 0.01
x_values <- seq(min(df_his$dlognondepth), max(df_his$dlognondepth), by = graph_reso)
xgap_values <- seq(min(df_his$dlognondepth), max(df_his$dlognondepth), by = graph_reso)

x_values_transform <- -(x_values)
xgap_values_transform <- -(x_values)


# Defining various functions to plot
NLPE_D <- function(dlognondepth)
      {( alpha0_D + alpha_D_G*( 1 + exp(gamma*(dlognondepth) ) )^-1 + alpha_D_L*( 1 + exp(-gamma*(dlognondepth) ) )^-1 )*dlognondepth}
TransF_D <- function(dlognondepth){alpha0_D + alpha_D_G*(1+exp(gamma*(dlognondepth) ) )^-1 + alpha_D_L*( 1 + exp(-gamma*(dlognondepth)))^-1}

F_D_G <- function(x){( 1 + exp( gamma*(dlognondepth) ) )^-1}
F_D_L <- function(x){( 1 + exp( -gamma*(dlognondepth) ) )^-1}

NLPE_values_D <- NLPE_D(dlognondepth=xgap_values)
TransF_values_D <- TransF_D(dlognondepth=xgap_values)
NLPE_values_D_transform <- NLPE_values_D
TransF_values_D_transform <- TransF_values_D
time <- seq(1:151)

#Plot
plot(x_values_transform , NLPE_values_D_transform, type = "l", main = "Depth elasticity Ramlosa", xlab = "dlognondepth", ylab = "NLPE")
plot(xgap_values_transform, TransF_values_D_transform, type = "l", main = "Smooth Transition Functions", xlab = "dlognondepth", ylab = "STF")
```

```{r plot linear vs nonlinear with discount}
c_0 <- par_LS.est[1]
alpha0_H <- par_LS.est[2]
alpha_H_G <- par_LS.est[3]
alpha_H_L <- par_LS.est[4]
alpha0_D <- par_LS.est[5]
alpha_D_G <- par_LS.est[6]
alpha_D_L <- par_LS.est[7]
phi_1_full <- par_LS.est[8]
phi_2_full <- par_LS.est[9]
  
linear_predict <- function(dlogavgpricebefore,dlognondepth,totalvolume1,avgfinalprice1){
  c_full_lm + alpha_0_full_lm*dlogavgpricebefore + alpha_0_disc_lm*dlognondepth + phi_1_full_lm*log(totalvolume1) + (phi_1_full_lm*phi_2_full_lm)*log(avgfinalprice1)
}


nonlinear_predict <- function(dlogavgpricebefore,dlognondepth,totalvolume1,avgfinalprice1)
{c_0 +(alpha0_H + alpha_H_G*( 1 + exp(gamma*(dlogavgpricebefore)))^-1 + alpha_H_L*( 1 + exp(-gamma*(dlogavgpricebefore)))^-1)*dlogavgpricebefore + (alpha0_D + alpha_D_G*( 1 + exp(gamma*(dlognondepth)))^-1 + alpha_D_L*( 1 + exp(-gamma*(dlognondepth)))^-1)*dlognondepth + phi_1_his*(log(df_his$totalvolume1))+(phi_1_full*phi_2_full*log(df_his$avgfinalprice1))}

pre_linear <- cbind(linear_predict(dlogavgpricebefore=df_his$dlogavgpricebefore,dlognondepth=df_his$dlognondepth,totalvolume1 = df_his$totalvolume1,avgfinalprice1 = df_his$avgfinalprice1),df_his$dlogavgpricebefore,c("linearwithdiscount"))

pre_nonlinear<- cbind(nonlinear_predict(dlogavgpricebefore=df_his$dlogavgpricebefore,dlognondepth=df_his$dlognondepth,totalvolume1 = df_his$totalvolume1,avgfinalprice1 = df_his$avgfinalprice1),df_his$dlogavgpricebefore,c("nonlinearwithdiscount"))

actual <- cbind(df_his$dlogtotalvolume,df_his$dlogavgpricebefore,c("actual"))

compare_actual_predict <- rbind(actual,pre_linear,pre_nonlinear)


plot(compare_actual_predict[,2], compare_actual_predict[,1], pch = 19,col = factor(compare_actual_predict[,3]),
     xlab="dlogPrice", ylab="dlogTotalVolume")
legend("topright",
       legend = levels(factor(compare_actual_predict[,3])),
       pch = 19,
       col = factor(levels(factor(compare_actual_predict[,3]))))
```

```{r Estimate with NLS (HistgapandDis) for loka}

LS_nonlinear_hisdisc <- function(parvec){
  
  F_H_G <- 1/(1+exp(gamma*(df_full$dlogavgpricebefore)))
  F_H_L <- 1/(1+exp(-gamma*(df_full$dlogavgpricebefore)))
  F_D_G <- 1/(1+exp(gamma*(df_full$dlognondepth)))
  F_D_L <- 1/(1+exp(-gamma*(df_full$dlognondepth)))
  

  ut <- df_full$dlogtotalvolume - (parvec[1] + (parvec[2]+ parvec[3]*F_H_G + parvec[4]*F_H_L)*df_full$dlogavgpricebefore
                                  + (parvec[5] + parvec[6]*F_D_G + parvec[7]*F_D_L)*df_full$dlognondepth
                            + parvec[8]*((log(df_full$totalvolume1))+parvec[9]*log(df_full$avgfinalprice1)))
  SSE <- sum(ut^2)
  return(SSE)
}

  gamma <- 500 #assumed
  
  
lm_full_linear <- lm(dlogtotalvolume ~ dlogavgpricebefore + dlognondepth + log(totalvolume1) + log(avgfinalprice1) ,data=df_full)

summary(lm_full_linear)


c_full_lm <- summary(lm_full_linear)$coefficients[1,1]
alpha_0_full_lm <- summary(lm_full_linear)$coefficients[2,1]
alpha_0_disc_lm <- summary(lm_full_linear)$coefficients[3,1]
phi_1_full_lm <- summary(lm_full_linear)$coefficients[4,1]
phi_2_full_lm <- (summary(lm_full_linear)$coefficients[5,1])/(summary(lm_full_linear)$coefficients[4,1]) # tfull coef = phi1*phi2
alpha_g_his_full_lm <- 0
alpha_l_his_full_lm <- -0.25
alpha_g_disc_full_lm <- 1
alpha_l_disc_full_lm <- -1


  
  parvec_1 <- c_full_lm
  parvec_2 <- alpha_0_full_lm
  parvec_3 <- alpha_g_his_full_lm
  parvec_4 <- alpha_l_his_full_lm
  parvec_5 <-  alpha_0_disc_lm
  parvec_6 <- alpha_g_disc_full_lm
  parvec_7 <- alpha_l_disc_full_lm 
  parvec_8 <- phi_1_full_lm
  parvec_9 <- phi_2_full_lm
  

Start_v_LS <- c(parvec_1,parvec_2,parvec_3,parvec_4,parvec_5,parvec_6,parvec_7,parvec_8,parvec_9)

  n <- dim(df_full)[1]
  k <- length(Start_v_LS)


LS_logL_nonlinear_his_constraint = optim(Start_v_LS,
                  fn = LS_nonlinear_hisdisc, # function to maximize
                  method = "BFGS",
                  control = list(fnscale = 1), # minimize the function
                  hessian = T # calculate Hessian matrix because we will need for confidence intervals
                  )

MSE_calculated <- LS_logL_nonlinear_his_constraint$value/(n-k)

paste("Calculated SE of model:",MSE_calculated)

par_LS.est<-LS_logL_nonlinear_his_constraint$par
OI<-solve(LS_logL_nonlinear_his_constraint$hessian)
par_LS.se<-sqrt(diag(OI))

Start_v_LS
par_LS.est

par_LS_name <- c("constant", "price_elas" ,"hgap_gain_slope","hgap_loss_slope","dgap_gain_slope","dgap_loss_slope",
                   "correction_1","correction_2")
par_LS <- data.table(cbind(par_LS_name,par_LS.est,par_LS.se))
par_LS$tstat <- as.numeric(par_LS$par_LS.est)/as.numeric(par_LS$par_LS.se)

par_LS 
```